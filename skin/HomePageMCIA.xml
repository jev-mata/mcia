<krpano>

	<!-- krpano 1.21 - Virtual Tour Skin --> 

	<!-- save the url path of this xml file (the url value will be adjusted during xml parsing) -->
	<vtourskinxmlpath url="./" />

	<!-- iPhone X safe-area support: use the horizontal safe-area only -->	
	<display safearea="h-only" />

	<!-- mouse / touch / keyboard(button) control settings - https://krpano.com/docu/xml/#control -->
	<control mouse="drag"  
	         zoomoutcursor="false"
	         draginertia="0.1"
	         dragfriction="0.9"
	         movetoaccelerate="1.0"
	         movetospeed="10.0"
	         movetofriction="0.8"
	         keybaccelerate="0.09"
	         keybfriction="0.94"
	         keybfovchange="0.25"
	         mousefovchange="1.0"
	         fovspeed="3.0"
	         fovfriction="0.9"
	         bouncinglimits="true"
         touchzoom="true"
         trackpadzoom="true"
         capturetouch="true"
		 usercontrol="all"
		 invertzoom="false"
		 zoomtocursor="true"
	       />
	<!-- mouse cursors - https://krpano.com/docu/xml/#cursors -->
	<cursors standard="default"
	         dragging="move"
	         moving="move"
	         />


	<!-- ensure stagescale 2x for mobile devices (regardless if mobilescale is 0.003 or 1.0) -->
	<krpano stagescale="calc:stagescale * 2" if="stagescale LT 1.0" devices="mobile" />


	<!-- VR support - https://krpano.com/plugins/webvr/ -->
	<include url="%VIEWER%/plugins/webvr.xml" />
	
	<!-- overwrite some settings from the webvr.xml for the skin integration -->
	<plugin name="webvr" keep="true" devices="webgl"
	        url="calc:skin_settings.webvr == true ? '%VIEWER%/plugins/webvr.js' : null"
	        onavailable="skin_webvr_onavailable();"
	        onentervr="skin_showloading(false); webvr_onentervr(); skin_webvr_setup(); skin_reloadscene_webvr();"
	        onexitvr="webvr_onexitvr(); skin_webvr_setup(); skin_reloadscene_webvr();"
	        />
	
	<!-- webvr button style (adjust to match skin style) -->
	<style name="webvr_button_style"
	       bgroundedge="calc:skin_settings.design_bgroundedge"
	       bgcolor="get:skin_settings.design_bgcolor" bgalpha="get:skin_settings.design_bgalpha"
	       bgborder="get:skin_settings.design_bgborder"
	       bgshadow="get:skin_settings.design_bgshadow"
	       css="calc:skin_settings.design_text_css + ' font-size:' + 20*webvr_setup_scale*webvr_button_scale + 'px;'"
	       />
	
	<!-- show a 'rotate the device' info when the mobile device is in portrait orientation in VR mode -->
	<layer name="webvr_rotate_to_landscape_request" keep="true" vr="true" devices="mobile"
	       url="rotate_device.png" scale="0.003"
	       align="top" edge="center" y="28%"
	       autoalpha="true" alpha="0.0"
	       enabled="false"
	       />
	
	<events name="skin_webvr_and_gyro_events" keep="true"
	        onxmlcomplete="skin_set_webvr_or_gyro_startup_view()"
	        onresize.mobile="skin_webvr_act_as_gyro_in_portrait_mode();"
	        onloadcomplete="delayedcall(0.003, if(webvr.isenabled AND scene.count GT 1 AND skin_settings.webvr_prev_next_hotspots, set(hotspot[skin_webvr_prev_scene].visible,true); set(hotspot[skin_webvr_next_scene].visible,true); ); );"
	        onviewchange=""
	        />
	
	<action name="startIdleTimer">
		delayedcall(600, restartScene);
	</action>

	<action name="restartScene">
	
    tween(layer[introLayer].alpha,1, 0.5, easeInOutCubic);  
     
	 set(layer[introLayer].enabled,true); 
	 set(layer[introLayer].visible,true); 
	 
	loadscene("scene_map-new", null,MERGE,ZOOMBLEND(0.8,0.4,easeInOutCubic));
	</action>

	<events  onkeydown="resetIdleTimer();" 
    onclick="resetIdleTimer();" 
    ontouchstart="resetIdleTimer();"/>

	<action name="resetIdleTimer">
		stopdelayedcall(restartScene_restartScene);
		delayedcall(restartScene_restartScene, 600, restartScene); // Reset the timer
	</action>

	<action name="skin_vrdevice_intro" autorun="onstart" scope="local" devices="mobilevr">
		<!-- show directly a big enterVR button -->
		set(layer[webvr_enterbutton], 
			align=center, y=0, padding='10 20', 
			css=calc(skin_settings.design_text_css + ' font-size:20px;text-align:center;'),
			html=calc((global.title ? '[i]'+global.title+'[/i][br]' : '') + '[span style="font-size:40px"]Enter VR[span]'), 
		);
		
		<!-- add a button to show the normal skin and hide the enter vr button -->
		addlayer('skin_hide_entervrbutton', button);
		set(button, keep=true,
			type=text,
			parent=webvr_enterbutton,
			align=bottom, edge=top, y=-60,
			text='Continue normal viewing...',
			bgalpha=0,
			css='color:#FFFFFF; text-decoration:underline;',
			onclick='removelayer(webvr_enterbutton); skin_showskin();'
		);
		
		<!-- hide the skin -->
		skin_hideskin(instant);
	</action>
	
	<action name="skin_webvr_onavailable" scope="local">
		if(device.mobilevr == false,
			<!-- remove the enter vr button from the webvr.xml, use the one from the skin -->
			removelayer(webvr_enterbutton);
		);
		
		<!-- update the skin buttons to add the skin vr button -->
		skin_arrange_buttons();
			
		<!-- call the original onavailable event from the webvr.xml -->
		webvr_onavailable();
	</action>
	
	<action name="skin_set_webvr_or_gyro_startup_view">
		if( (webvr.isenabled == true AND skin_settings.webvr_keeplookingdirection == false AND have3dtransition == false) OR (!webvr.isenabled AND plugin[skin_gyro].enabled == true AND skin_settings.gyro_keeplookingdirection == false AND have3dtransition == false),
			skin_lookat( get(xml.view.hlookat) );
		);
	</action>
	
	<action name="skin_webvr_setup">
		if(webvr.isenabled,
			copy(skin_settings.loadscene_flags_backup, skin_settings.loadscene_flags);
			set(skin_settings.loadscene_flags, MERGE|KEEPVIEW|KEEPMOVING|NOPREVIEW);
			skin_webvr_act_as_gyro_in_portrait_mode(true);
			if(scene.count GT 1 AND skin_settings.webvr_prev_next_hotspots,
				set(hotspot[skin_webvr_prev_scene].visible, true);
				set(hotspot[skin_webvr_next_scene].visible, true);
				set(events[skin_webvr_and_gyro_events].onviewchange, skin_webvr_menu_following());
			);
		  ,
			if(skin_settings.loadscene_flags_backup !== null, copy(skin_settings.loadscene_flags, skin_settings.loadscene_flags_backup); );
			if(layer[webvr_rotate_to_landscape_request], tween(layer[webvr_rotate_to_landscape_request].alpha, 0.0, 0.0); );
			set(hotspot[skin_webvr_prev_scene].visible, false);
			set(hotspot[skin_webvr_next_scene].visible, false);
			set(events[skin_webvr_and_gyro_events].onviewchange, null);
		);
	</action>
	
	<action name="skin_webvr_act_as_gyro_in_portrait_mode" scope="local" args="setupcall">
		if(device.mobile AND webvr.isenabled,
			div(aspect, stagewidth, stageheight);
			if(aspect != global.skin_webvr_lastaspect OR setupcall == true,
				copy(global.skin_webvr_lastaspect, aspect);
				if(stagewidth GT stageheight,
					<!-- landscape orientation - use stereo rendering and a direct/fast gyro sensor mode -->
					set(display.stereo, true);
					set(webvr.mobilevr_sensor_mode, 3);
					webvr.update();
					tween(layer[webvr_rotate_to_landscape_request].alpha, 0.0, 0.0);
				  ,
					<!-- portrait orientation - use normal rendering and a smoother/slower gyro sensor mode -->
					set(display.stereo, false);
					set(webvr.mobilevr_sensor_mode, 1);
					webvr.update();
					tween(layer[webvr_rotate_to_landscape_request].alpha, 1.0);
					delayedcall(3.0, tween(layer[webvr_rotate_to_landscape_request].alpha, 0.0, 1.0); );
				);
			);
		  ,
			set(global.skin_webvr_lastaspect, 0);
		);
	</action> 
	<style name="imageListImage_text" css="text-align:center;margin-top:1%;color:white;font-size:calc((2.6vh + 0.5vw)/2);"/>
	<style name="imageListImageScene"   
	width.desktop="calc: (stagewidth * 0.64) / 8" 
	width.mobile="calc: (stagewidth * 0.8) / 4" 
	width.tablet="calc: (stagewidth * 0.6) / 4" 
	height.desktop="95%"  
	 height.mobile="calc: (stageheight * 0.12)"  
	 height.tablet="95%"  
                bgroundedge="10"  
                bgalpha="0"
                bgcolor="0x000000"
                enabled="true"
                bgcapture="true"
                onover="if(get(bgcolor)=='0x000000'), tween(bgalpha, 0.3, 0.5, easeInOutCubic) );"
                onout="if(get(bgcolor)=='0x000000'), tween(bgalpha, 0, 0.5, easeInOutCubic) );"
                onclick="loadscene(get(linkedscene), null,MERGE,ZOOMBLEND(0.8,0.4,easeInOutCubic));"
                flowoverflow="true"
                flowspacing="5"
                align="leftmiddle" 
				edge="leftmiddle"
				 />
	<!-- VR scene switching hotspots -->
	<style name="skin_webvr_menu_style" torigin="view" depth="1000" scale="0.00315" distorted="true" ath="0" atv="45" alpha="0.003" />
	<hotspot name="skin_webvr_prev_scene" keep="true" style="skin_base|skin_webvr_menu_style" crop="0|64|64|64"  ox="-88" onover="tween(scale,0.750);" onout="tween(scale,0.00315);" vr_timeout="750" onclick="skin_nextscene_loop(-1);" visible="false" devices="webgl" />
	<hotspot name="skin_webvr_next_scene" keep="true" style="skin_base|skin_webvr_menu_style" crop="64|64|64|64" ox="+88" onover="tween(scale,0.750);" onout="tween(scale,0.00315);" vr_timeout="750" onclick="skin_nextscene_loop(+1);" visible="false" devices="webgl" />
	
	<!-- floating/following VR hotspots -->
	<action name="skin_webvr_menu_following" type="Javascript"><![CDATA[
		var hs1 = krpano.get("hotspot[skin_webvr_prev_scene]");
		var hs2 = krpano.get("hotspot[skin_webvr_next_scene]");
		if(!hs1.hovering && !hs2.hovering)
		{
			var f = 0.01;	// following speed factor
			var h = krpano.view.hlookat;
			var v = krpano.view.vlookat;
			var hsh = hs1.ath;
			var hsv = hs1.atv;
			h   = (h  -(h|0))   + (((h|0)  +360180)%360) - 180.0;
			v   = (v  -(v|0))   + (((v|0)  +360180)%360) - 180.0;
			hsh = (hsh-(hsh|0)) + (((hsh|0)+360180)%360) - 180.0;
			var dh = h - hsh;
			dh += (dh > 180) ? -360 : (dh < -180) ? 360 : 0
			hsh += dh*f;
			var a = Math.abs(v - hsv) / 90.0;
			a = 1.0 * Math.max(1.0 - 2.0*Math.sqrt(a), 0);
			v = v + 55.0 - v*1.5;
			hsv = hsv*(1.0 - f) + v*f;
			hs1.ath = hs2.ath = hsh;
			hs1.atv = hs2.atv = hsv;
			hs1.alpha = hs2.alpha = a;
		}
	]]></action>
	<!-- VR support -->



	<!-- skin styles -->

	<!-- skin_base - the base skin image -->
	<style name="skin_base" url="calc:vtourskinxmlpath.url + skin_settings.design_skin_images" />


	<!-- skin_glow - button glowing -->
	<style name="skin_glow"
	       scalechildren="false"
	       ondown.addevent="copy(skin_lockglow,name); skin_buttonglow(get(name));"
	       onover.addevent="if(skin_lockglow === null, copy(skin_lockglow,name); skin_buttonglow(get(name),0.3) );"
	       onout.addevent="if(skin_lockglow === name AND !pressed, skin_buttonglow(null);delete(skin_lockglow); );"
	       onup.addevent="delayedcall(0, if(hovering AND enabled, skin_buttonglow(get(name),0.3); , skin_buttonglow(null);delete(skin_lockglow); ); );"
	       />

	<!-- skin_thumbtext_style - style/textfield for the (optional, skin_settings.thumbs_text) thumbnails texts -->
	<style name="skin_thumbtext_style" type="text" align="bottom" width="100%" y="5" enabled="false" bg="false" bgborder="false" css="calc:skin_settings.design_text_css + ' text-align:center; font-size:10px;'" txtshadow="get:skin_settings.design_text_txtshadow" />

	<!-- skin_hotspotstyle - style for the hotspots -->
	<style name="caap-tower" url="new-skin/map-icon-hover/caap-tower.png" edge="top" distorted="true"
	       tooltip="Caap Tower"
	       linkedscene=""
	       linkedscene_lookat=""
	       linkedscene_hoffset="0"
	       use3dtransition="false"
		   isClicked="false"
	       
	       onclick.desktop="loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));back2map_BTN_show();"
	       onclick.mobile="
		   if(alpha==1,  
				loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));
				back2map_BTN_show();
		   ,  
				tween(scale,0.00272);
				tween(alpha,1);
				tween(hotspot[caap-tower_pulse].alpha,0,0.5 ,easeInOutCubic)
		   );"
	       onclick.tablet="
		   if(alpha==1,  
				loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));
				back2map_BTN_show();
		   ,  
				tween(scale,0.00272);
				tween(alpha,1);
				tween(hotspot[caap-tower_pulse].alpha,0,0.5 ,easeInOutCubic)
		   );"
	       depth="1000"
	       scale="0.0027"
		   alpha="0"
	       onover.addevent="if(layer[showtooltip].isShow==true, tween(scale,0.00272);tween(alpha,1);tween(hotspot[caap-tower_pulse].alpha,0,0.5 ,easeInOutCubic), );"
	       onout.addevent="tween(scale,0.0027);tween(alpha,0);tween(hotspot[caap-tower_pulse].alpha,1,0.5 ,easeInOutCubic);"
	       onloaded.addevent="skin_hotspotstyle_setup();"
	      >
        <alpha mask="true" />
    </style>
	<style name="MCIAa-building" url="new-skin/map-icon-hover/MCIAa-building.png" edge="top" distorted="true"
	       tooltip="MCIA Build"
	       linkedscene=""
	       linkedscene_lookat=""
	       linkedscene_hoffset="0"
	       use3dtransition="false"
		   isClicked="false"
	       
	       onclick.desktop="loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));back2map_BTN_show();"
	       onclick.mobile="
		   if(alpha==1,  
				loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));
				back2map_BTN_show();
		   ,  
				tween(scale,0.00272);
				tween(alpha,1);
				tween(hotspot[MCIAa-building_pulse].alpha,0,0.5 ,easeInOutCubic)
		   );"
	       onclick.tablet="
		   if(alpha==1,  
				loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));
				back2map_BTN_show();
		   ,  
				tween(scale,0.00272);
				tween(alpha,1);
				tween(hotspot[MCIAa-building_pulse].alpha,0,0.5 ,easeInOutCubic)
		   );"
	       depth="1000" 
	       scale="0.0027"
		   alpha="0"
	       onover.addevent="if(layer[showtooltip].isShow==true, tween(scale,0.00272);tween(alpha,1);tween(hotspot[MCIAa-building_pulse].alpha,0,0.5 ,easeInOutCubic), );"
	       onout.addevent="tween(scale,0.0027);tween(alpha,0);tween(hotspot[MCIAa-building_pulse].alpha,1,0.5 ,easeInOutCubic);"
	       onloaded.addevent="skin_hotspotstyle_setup();"
	     >
        <alpha mask="true" />
    </style>
	<style name="terminal-1" url="new-skin/map-icon-hover/terminal-1.png" edge="top" distorted="true"
	       tooltip="Terminal 1"
	       linkedscene=""
	       linkedscene_lookat=""
	       linkedscene_hoffset="0"
	       use3dtransition="false"
		   isClicked="false" 
	       onclick.desktop="loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));back2map_BTN_show();"
	       onclick.mobile="
		   if(alpha==1,  
				loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));
				back2map_BTN_show();
		   ,  
				tween(scale,0.00272);
				tween(alpha,1);
				tween(hotspot[terminal-1_pulse].alpha,0,0.5 ,easeInOutCubic)
		   );"
	       onclick.tablet="
		   if(alpha==1,  
				loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));
				back2map_BTN_show();
		   ,  
				tween(scale,0.00272);
				tween(alpha,1);
				tween(hotspot[terminal-1_pulse].alpha,0,0.5 ,easeInOutCubic)
		   );"
	       depth="1000"
	       scale="0.0027"
		   alpha="0"
	       onover.addevent="if(layer[showtooltip].isShow==true, tween(scale,0.00272);tween(alpha,1);tween(hotspot[terminal-1_pulse].alpha,0,0.5 ,easeInOutCubic), );"
	       onout.addevent="tween(scale,0.0027);tween(alpha,0);tween(hotspot[terminal-1_pulse].alpha,1,0.5 ,easeInOutCubic);"
	       onloaded.addevent="skin_hotspotstyle_setup();"
	       >
        <alpha mask="true" />
    </style>
		<style name="skin_hotspotstyle_streetview" url="%FIRSTXML%/skin/ring_2.gif" edge="top" distorted="true"
	       tooltip=""
	       linkedscene=""
	       linkedscene_lookat=""
	       linkedscene_hoffset="0"
	       use3dtransition="false"
		   isClicked="false"
		   renderer="css3d" 
	       onclick="
		   if(device.mobile OR device.tablet, 
				if(get(layer[get(name)].isClicked), 
					skin_hotspotstyle_click(); 
				,
					set(layer[get(name)].isClicked, true);  showtext(get(scene[get(linkedscene)].title), showtext_3); 
				);
			,
				set(layer[get(name)].isClicked, false);
				skin_hotspotstyle_click(); 
		   );
		   "
	       depth="1000"
	       scale="0.08" 
	       onloaded.addevent="skin_hotspotstyle_setup();"
	       />

	<textstyle name="showtext_2" 
	origin="cursor" edge="bottom" 
	xoffset="0" yoffset="-3" 
	fadeintime="0.0" showtime="0.1" 
	fadetime="0.0" font="Verdana" 
	fontsize="22.0" bold="false" 
	italic="false" textcolor="0xffffff" 
	textalign="none" padding="3 10" css="" 
	background="true" backgroundcolor="0xff9900" 
	backgroundalpha="1" border="true" borderwidth="2" 
	bordercolor="0xFFFFFF" roundedge="5"  shadow="5" 
	shadowrange="5.0" shadowangle="45"  shadowcolor="0x000000" 
	shadowalpha="1.0" textshadow="0.0" textshadowrange="4.0" 
	textshadowangle="45" textshadowcolor="0x000000" 
	textshadowalpha="1.0" noclip="true" />
	
	<textstyle name="showtext_3" 
	origin="cursor" edge="bottom" 
	xoffset="0" yoffset="-3" 
	fadeintime="0.0" showtime="4.1" 
	fadetime="0.0" font="Verdana" 
	fontsize="22.0" bold="false" 
	italic="false" textcolor="0xffffff" 
	textalign="none" padding="3 10" css="" 
	background="true" backgroundcolor="0xff9900" 
	backgroundalpha="1" border="true" borderwidth="2" 
	bordercolor="0xFFFFFF" roundedge="5"  shadow="5" 
	shadowrange="5.0" shadowangle="45"  shadowcolor="0x000000" 
	shadowalpha="1.0" textshadow="0.0" textshadowrange="4.0" 
	textshadowangle="45" textshadowcolor="0x000000" 
	textshadowalpha="1.0" noclip="true" />
<style name="flag_menu"

                    onhover="set(layer[get(name)].scale,0.062); tween(layer[get(name)].alpha, 0.7,0.5,easeInOutCubic); showtext(*tooltip, showtext_2); "
                    ondown="set(layer[get(name)].scale,0.062); tween(layer[get(name)].alpha, 0.7,0.5,easeInOutCubic); showtext(*tooltip, showtext_2); "
                    onout="set(layer[get(name)].scale,0.06); tween(layer[get(name)].alpha, 1,0.5,easeInOutCubic);"  
                    onup="set(layer[get(name)].scale,0.06); tween(layer[get(name)].alpha, 1,0.5,easeInOutCubic);"  
	/>
	<action name="back2map_BTN_show">
	set(layer[backtomap].visibility,true);
	tween(layer[backtomap].alpha,1,0.5,easeInOutCubic);
	</action>
	<action name="back2map_BTN_hide">
	tween(layer[backtomap].alpha,0,0.5,easeInOutCubic);
	delayedcall(0.5,set(layer[backtomap].visibility,false));


	</action>
	<style name="menuBTN"
	width="prop" 
	height="100%"
	align="centermiddle"
	edge="centermiddle"
	scale="1" 
	onhover=" showtext(*tooltip, showtext_2); "
	onclick="
	stopdelayedcall(imageListMainContainer2_d);
	stopdelayedcall(introLayer_d);
	stopdelayedcall(backtomap_v);
	stopdelayedcall(upperRightTittle_v);
	stopdelayedcall(welcomeAvatar_a); 
	stopdelayedcall(cont_fp_all_al);
	stopdelayedcall(close_fp_bg_v);
	stopdelayedcall(floormapLayer_v);
	stopdelayedcall(isFloormap_act);
	stopdelayedcall(open_flpl_b_v); 
	stopdelayedcall(cbsettings_a); 

	if(layer[get(name)].url==get(active),
		
		if(layer[get(name)].name == get(layer[streetview_btn].name), 
		,
			if(layer[get(name)].name == get(layer[home].name), 
			,
				resetbuttonAll();
			);
		);
			mapOnClose(); 
			
		if(layer[flight_grid_layout].visible,
			set(layer[flightInfo].url, get(layer[flightInfo].passive));
			set(layer[flight_grid_layout].enabled, false);
			tween(layer[flight_grid_layout].alpha, 0, 0.5,easeInOutCubic); 
		);
		if(layer[filterLayer].visible,
			tween(layer[filterLayer].alpha, 0, 0.5, easeInOutCubic); 
			delayedcall(0.5,set(layer[filterLayer].visible,false););
			set(layer[establishment].url,get(layer[establishment].passive));
		);
		minimizeFloorPlan();
	, 
		resetbuttonAll();
		if(layer[get(name)].name == get(layer[map].name),  
			mapOnclick();
		,  
			set(layer[get(name)].url, get(active));  
				mapOnClose();
		);
		if(layer[get(name)].linkedscene,
			if(scene[get(xml.scene)].name == scene[get(linkedscene)].name,
			,
				set(layer[noted].text, get(scene[get(linkedscene)].name));
				loadscene(get(linkedscene), null,MERGE,ZOOMBLEND(0.8,0.4,easeInOutCubic));
				back2map_BTN_show();
				set(layer[get(name)].bgalpha,0);
				set(close_pl_butt, true); 
				close_flpl();
			);
		);
				
		action(filterLayerToggle);
		floormapLayerToggle();
		open_flightInfo();
	);


		 " 
	>
	
	</style> 
	<action name="open_flightInfo">
		if(layer[get(name)].name === layer[flightInfo].name ,
			tween(layer[flight_grid_layout].alpha, 1, 0.5,easeInOutCubic);
    		set(layer[flightInfo].url,get(layer[flightInfo].active));
			set(layer[flight_grid_layout].enabled, true);
			set(layer[flight_grid_layout].visible, true);,

			tween(layer[flight_grid_layout].alpha, 0, 0.5,easeInOutCubic);
    		set(layer[flightInfo].url,get(layer[flightInfo].passive));
			set(layer[flight_grid_layout].enabled, false);
			set(layer[flight_grid_layout].visible, false);
		);
	</action>  
<action  name="filterLayerToggle">

	if(layer[get(name)].name === layer[establishment].name,
		tween(layer[filterLayer].alpha, 1, 0.5, easeInOutCubic);
		set(layer[filterLayer].visible,true);
		set(layer[showtooltip].isShow,false); 
		,
		tween(layer[filterLayer].alpha, 0, 0.5, easeInOutCubic); 
		delayedcall(0.5,set(layer[filterLayer].visible,false););
		set(layer[showtooltip].isShow,true); 
    	set(layer[establishment].url,get(layer[establishment].passive));
		<!-- resetbuttonAll(); -->
	);
</action>
<action  name="flightInfoToggle">

	if(layer[get(name)].name == layer[flightInfo].name,
		tween(layer[filterLayer].alpha, 1, 0.5, easeInOutCubic);
		set(layer[filterLayer].visible,true);
		,
		tween(layer[filterLayer].alpha, 0, 0.5, easeInOutCubic); 
		delayedcall(0.5,set(layer[filterLayer].visible,false););
	);
</action>

<action name="floormapShowMap">
 
	
set(layer[floorplan].url, get(layer[floorplan].active));
			set(layer[cont_fp_all].align, 'center');
			set(layer[cont_fp_all].edge, 'center');
			set( layer[floormapLayer].enable, true);
			set( layer[floormapLayer].visible, true);

			tween(layer[floormapLayer].alpha, 1,0.5, easeInOutCubic); 
			tween(layer[cont_fp_all].scale,1, 0.4, easeInOutCubic);
			 if(device.mobile,
					tween(layer[cont_fp_all].y, -10%,  1.0, easeInOutCubic);  
					<!-- Calculate 70% of the screen width -->
					set(maxWidth_cont_fp, calc(stagewidth * 0.7));
					<!-- Calculate 35% of the screen height -->
					set(maxHeight_cont_fp, calc(stageheight * 0.35));  
				,
					if(device.tablet,
						tween(layer[cont_fp_all].y, 15%,  1.0, easeInOutCubic);  
						<!-- Calculate 60% of the screen width -->
						set(maxWidth_cont_fp, calc(stagewidth * 0.6));
						<!-- Calculate 45% of the screen height -->
						set(maxHeight_cont_fp, calc(stageheight * 0.45));  
					,
						tween(layer[cont_fp_all].y, -13%,  1.0, easeInOutCubic);  
						<!-- Calculate 50% of the screen width -->
						set(maxWidth_cont_fp, calc(stagewidth * 0.5));
						<!-- Calculate 45% of the screen height -->
						set(maxHeight_cont_fp, calc(stageheight * 0.45));  
					);
				);
			tween(layer[cont_fp_all].x, 0,  1.0, easeInOutCubic);   


    		set(layer[cont_fp_all].height, calc(stageheight * 0.45));
			open_flpl();
			set(close_pl_butt, false); 
			set(layer[plan_cont_fp2].visible,true);
			tween(layer[open_flpl_b].alpha,1, 0.5, easeInOutCubic); 
			set(0.5, layer[open_flpl_b].visible,true); 

			tween(layer[close_fp_bg].alpha,0, 0.5, easeInOutCubic); 
			delayedcall(close_fp_bg_v,0.5, set(layer[close_fp_bg].visible,false)); 
	
</action>
<style name="skin_hotspotstyle_text"  
		   bgcolor="0xff9c04"
		   bgalpha="1"
		   bgborder="2 0xFFFFFF 1"
		   bgroundedge="5"
		   distorted="true" 
		   scale="1.5"
		   css="color:white;"
		   
         type="text"
         renderer="auto"  
         oversampling="1.0"
         mipmapping="false"
		   padding="7 20 7 20"
		   />
<action  name="floormapLayerToggle"> 
	if(get(name)==floorplan,
			set(floorplan_Init,true);
			floormapShowMap();
			
		,

			minimizeFloorPlan();
			
    		set(layer[floorplan].url,get(layer[floorplan].passive));
		); 
</action>

<style name="imageListImage_compo" 
	
/> 
  <!-- Define an action to enable touch --> 
<action name="minimizeFloorPlan">
	
	
			tween(layer[floormapLayer].alpha, 0, 0.5, easeInOutCubic);
			delayedcall(floormapLayer_v,0.5,set(layer[floormapLayer].visible, false););
			if(get(layer[cont_fp_all].align)== bottomright,
			,
				set(layer[cont_fp_all].align, 'center');
				set(layer[cont_fp_all].edge, 'center');
				if(device.mobile,
					tween(layer[cont_fp_all].x, 34%, 1.0,easeInOutCubic,
						tween(layer[cont_fp_all].y, 34%, 1.0,easeInOutCubic); 
					);  
				,
					tween(layer[cont_fp_all].x, 38%, 1.0,easeInOutCubic,
						tween(layer[cont_fp_all].y, 28%, 1.0,easeInOutCubic); 
					);  
				);  
				
				tween(layer[cont_fp_all].scale,0.4, 0.5, easeInOutCubic,
					delayedcall(isFloormap_act,2,
						set(layer[cont_fp_all].x, 1%); 
						set(layer[cont_fp_all].y, 8%); 
						
						set(layer[cont_fp_all].align, 'bottomright');
						set(layer[cont_fp_all].edge, 'bottomright');

						
						if(get(scene[get(xml.scene)].isFloormap),
						, 
								closeFloormap(); 
							<!-- set(minimizeFloorPlan,false); -->
							
						);
					);
				); 
			);
			
			set(layer[plan_cont_fp2].visible,true	);

			
			close_flpl(); 
			if(scene[get(xml.scene)].isFloormap,
			,

				set(close_pl_butt, false); 
				set(layer[open_flpl_b].enabled,false);
				tween(layer[open_flpl_b].alpha, 0, 0.5,easeInOutCubic);
				set(layer[open_flpl_b].visible,false);
			);


			tween(layer[close_fp_bg].alpha,1, 0.5, easeInOutCubic); 
			set( layer[close_fp_bg].visible,true); 

			set(close_pl_butt, true);
			<!-- tween(layer[open_flpl_b].alpha,0, 0.5, easeInOutCubic); 
			delayedcall(open_flpl_b_v,0.5, set(layer[open_flpl_b].visible,false));  -->
			
	
	
</action>

<action name="closeFloormap">

			tween(layer[cont_fp_all].scale,0, 0.5, easeInOutCubic); 
			delayedcall(floormapLayer_v2,0.5,set(layer[floormapLayer].visible, false););
	
</action>


<action name="mapOnclick">  
    set(layer[mapExplore].enabled,true);
    set(layer[mapExplore].visible,true);
	set(layer[showtooltip].isShow,false); 

    tween(layer[mapExplore].alpha, 1, 0.5, easeInOutCubic); 
    tween(layer[showtext_2].alpha, 0, 0.5, easeInOutCubic); 
	set(layer[map].url,get(layer[map].active));
</action> 
<action name="mapOnClose">
    tween(layer[mapExplore].alpha, 0, 0.5, easeInOutCubic);  
    set(layer[mapExplore].visible,false);
	set(layer[showtooltip].isShow,true);

	delayedcall(0.5, set(layer[mapExplore].enabled,false); );
	 set(layer[map].url,get(layer[map].passive));
</action> 
<style name="mapExploreListItem" height="prop" 
width="23%"  
scale="1"  
flowspacing.desktop="20" 
minwidth="60" 
flowspacing.mobile="10" 
flowspacing.tablet="10" 
onover="tween(layer[get(name)].scale,1,0.5,smooth);" 
onout="tween(layer[get(name)].scale,0.95,0.5,smooth);"  
enabled="true">

</style>


<action name="out_filterItemHover">
for(set(i, 0), i LT layer.count, inc(i), 
				if(layer[get(i)].parent == get(name), 
					if(layer[get(i)].type==text, set(layer[get(i)].css,"color:#dd7a00;text-align:center;margin-top:0.7vh;font-size:calc((1.3vh + 1.3vw)/2);font-weight:bold"));
				)
			);
	
	
</action>
<action name="on_filterItemHover">
for(set(i, 0), i LT layer.count, inc(i), 
				if(layer[get(i)].parent == get(name), 
					if(layer[get(i)].type==text, set(layer[get(i)].css,"color:#eb242c;text-align:center;margin-top:0.7vh;font-size:calc((1.3vh + 1.3vw)/2);font-weight:bolder"));
				)
			);
	
	
</action>

<style name="filter"  bgcolor="0xFFFFFF"
css="color:black;font-size:calc((1.7vh + 1.5vw)/2);line-height: 1;text-align:center;"
align.desktop="bottomleft"
align.mobile="bottomleft"
align.tablet="bottomleft"
edge.desktop="topleft" 
edge.mobile="bottomleft" 
edge.tablet="bottomleft" 
 height="auto" width="auto"
maxheight="50"
minheight="20"
enabled="true"
bgcapture="true"
bgshadow="0 2 10 0x000000 0.5"
padding.desktop="8 17 8 17"
padding.tablet="8 17 8 17"
padding.mobile="5 10 5 10"
bgroundedge="10"
flowspacing.desktop="4 8 4 8"
flowspacing.tablet="4 8 4 8"
flowspacing.mobile="2 4 2 4"
onclick="startFilter;"
>

</style> 
<style name="filterListItem"  type="container" 
flowchildren="v"
  align="topleft"
bgalpha="0"
bgcolor="0x000000"
height.desktop="auto" 
height.mobile="auto" 
height.tablet="auto" 
width.desktop="24.99%" 
scale="1"
width.mobile="49.9%"   
width.tablet="49.9%"  
maxwidth.tablet="300"    
onover="on_filterItemHover()"  
enabled="true"
bgcapture="true" onout="out_filterItemHover" onclick="filterLayerToggle();loadscene(get(linkedscene), null,MERGE,ZOOMBLEND(0.8,0.4,easeInOutCubic));">
</style>
<style name="filterListItemText"

align="top"
edge="top"
	width="100%" bgalpha="0" height.mobile="calc:(stageheight * 0.022)"  height.tablet="calc:(stageheight * 0.042)"  height.desktop="calc:(stageheight * 0.062)"   keep="true" css="color:#dd7a00;text-align:center;margin-top:0.7vh;font-size:calc((1.3vh + 1.3vw)/2);font-weight:bold; "
/>

<style name="filterListItemImg"  type="container" enabled="false" bgcapture="false"   
align="lefttop"
edge="lefttop"
                   x="0"
                   y="0"
height.mobile="calc:(stageheight * 0.1)" height.tablet="calc:(stageheight * 0.2)" height.desktop="calc:(stageheight * 0.18)" width="96%" bgshadow="3 3 6 2 0x000000 1"  

                        bgroundedge="10" >
</style>
<action name="initButtonAll"> 
 set(layer[map].url,get(layer[map].passive));
 set(layer[home].url,get(layer[home].active));
 set(layer[streetview_btn].url,get(layer[streetview_btn].passive));
 set(layer[establishment].url,get(layer[establishment].passive));
 set(layer[floorplan].url,get(layer[floorplan].passive));
 set(layer[floorplan2].url,get(layer[floorplan2].passive));
</action> 
	<style name="backtomap" url="%FIRSTXML%/assets/skin/back-to-map.png" edge="top" distorted="true"
	       tooltip="Back to Map"
	       linkedscene=""
	       linkedscene_lookat=""
	       linkedscene_hoffset="0"
	       use3dtransition="false"
		   isClicked="false"
	       onclick="loadscene(get(linkedscene), null,MERGE,ZOOMBLEND(0.8,0.4,easeInOutCubic));"
	       depth="1000"
	       scale="0.1"
	       onover.addevent="tween(scale,0.12);"
	       onout.addevent="tween(scale,0.1);"
	       onloaded.addevent="skin_hotspotstyle_setup();"
	       />
	<style name="terminal-2" url="%FIRSTXML%/skin/new-skin/map-icon-hover/terminal-2.png" edge="top" distorted="true"
	       tooltip="Terminal 2"
	       linkedscene=""
	       linkedscene_lookat=""
	       linkedscene_hoffset="0"
	       use3dtransition="false"
		   isClicked="false"
	       
	       onclick.desktop="loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));back2map_BTN_show();"
	       onclick.mobile="
		   if(alpha==1,  
				loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));
				back2map_BTN_show();
		   ,  
				tween(scale,0.00272);
				tween(alpha,1);
				tween(hotspot[terminal-2_pulse].alpha,0,0.5 ,easeInOutCubic)
		   );"
	       onclick.tablet="
		   if(alpha==1,  
				loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));
				back2map_BTN_show();
		   ,  
				tween(scale,0.00272);
				tween(alpha,1);
				tween(hotspot[terminal-2_pulse].alpha,0,0.5 ,easeInOutCubic)
		   );"
	       depth="1000"
		   alpha="0"
	       scale="0.0027"
	       onover.addevent="if(layer[showtooltip].isShow==true,tween(scale,0.00272);tween(alpha,1);tween(hotspot[terminal-2_pulse].alpha,0,0.5 ,easeInOutCubic), );"
	       onout.addevent="tween(scale,0.0027);tween(alpha,0);tween(hotspot[terminal-2_pulse].alpha,1,0.5 ,easeInOutCubic);"
	       onloaded.addevent="skin_hotspotstyle_setup();"
	      >
        <alpha mask="true" />
    </style>
	<style name="waterfront" url="%FIRSTXML%/skin/new-skin/map-icon-hover/waterfront.png" edge="top" distorted="true"
	       tooltip="Waterfront"
	       linkedscene=""
	       linkedscene_lookat=""
	       linkedscene_hoffset="0"
	       use3dtransition="false"
		   isClicked="false"
	       
	       onclick.desktop="loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));back2map_BTN_show();"
	       onclick.mobile="
		   if(alpha==1,  
				loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));
				back2map_BTN_show();
		   ,  
				tween(scale,0.00272);
				tween(alpha,1);
				tween(hotspot[waterfront_pulse].alpha,0,0.5 ,easeInOutCubic)
		   );"
	       onclick.tablet="
		   if(alpha==1,  
				loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));
				back2map_BTN_show();
		   ,  
				tween(scale,0.00272);
				tween(alpha,1);
				tween(hotspot[waterfront_pulse].alpha,0,0.5 ,easeInOutCubic)
		   );"
	       depth="1000"
		   alpha="0"
	       scale="0.0027"
	       onover.addevent="if(layer[showtooltip].isShow==true, tween(scale,0.00272);tween(alpha,1);tween(hotspot[waterfront_pulse].alpha,0,0.5 ,easeInOutCubic), );"
	       onout.addevent="tween(scale,0.0027);tween(alpha,0);tween(hotspot[waterfront_pulse].alpha,1,0.5 ,easeInOutCubic);"
	       onloaded.addevent="skin_hotspotstyle_setup();"
	      >
        <alpha mask="true" />
    </style>

	<style name="streetview" url="%FIRSTXML%/skin/new-skin/map-icon-hover/streetview.png" edge="center" 
	       tooltip="Streetview"
	       linkedscene=""
	       linkedscene_lookat=""
	       linkedscene_hoffset="0"
	       
	       onclick.desktop="loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));back2map_BTN_show();"
	       onclick.mobile="
		   if(alpha==1,  
				loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));
				back2map_BTN_show();
		   ,  
				tween(scale,0.00272);
				tween(alpha,1);
				tween(hotspot[streetview_pulse].alpha,0,0.5 ,easeInOutCubic)
		   );"
	       onclick.tablet="
		   if(alpha==1,  
				loadscene(get(linkedscene2), null,MERGE,ZOOMBLEND(0.8,3,easeInOutCubic));
				back2map_BTN_show();
		   ,  
				tween(scale,0.00272);
				tween(alpha,1);
				tween(hotspot[streetview_pulse].alpha,0,0.5 ,easeInOutCubic)
		   );"
	       depth="1000"
	       scale="0.00268"
		   alpha="0"
	       onover.addevent="if(layer[showtooltip].isShow==true, tween(scale,0.0027); tween(alpha,1);tween(hotspot[streetview_pulse].alpha, 0,0.5 ,easeInOutCubic), );"
	       onout.addevent="tween(scale,0.00268);tween(alpha,0);tween(hotspot[streetview_pulse].alpha, 1,0.5 ,easeInOutCubic);"
	       onloaded.addevent="skin_hotspotstyle_setup();"
		   mask="true"
	       >
		   
        <alpha mask="true" /> 
	</style>  
	<!-- <action name="startup" autorun="onstart">
		loadscene(get(startscene,scene[0].name), null, MERGE);
		delayedcall(change, 5, change_scene(1));
		
	</action> -->

<layer name="versioninfo" visible="false" />

	<action name="change_scene">
		loadscene(get(scene[%1].name), null, MERGE|KEEPVIEW|KEEPMOVING|NOPREVIEW, BLEND(1));
		add(new_scene, %1, 1);
		if(new_scene GE scene.count, set(new_scene, 0));
		delayedcall(change, 5, change_scene(get(new_scene)));
	</action>
	<!-- skin_hotspotstyle - style for the hotspots -->
	<style name="pulse"  url="%FIRSTXML%/skin/pulse.gif" edge="center" distorted="true"
	       tooltip=""
	       linkedscene=""
	       linkedscene_lookat=""
		   renderer="css3d" 
	       linkedscene_hoffset="0" 
		   enabled="false"
		   bgcapture="false"
	       onclick.desktop="
				set(layer[get(name)].isClicked, false);
				skin_hotspotstyle_click(); 
		   "
	       onclick.mobile="
				if(get(layer[get(name)].isClicked), 
					skin_hotspotstyle_click(); 
				,
					set(layer[get(name)].isClicked, true);  showtext(get(scene[get(linkedscene)].title), showtext_3); 
				);
		   "
	       onclick.tablet="
				if(get(layer[get(name)].isClicked), 
					skin_hotspotstyle_click(); 
				,
					set(layer[get(name)].isClicked, true);  showtext(get(scene[get(linkedscene)].title), showtext_3); 
				);
		   "
	       depth="1000"
	       scale="0.0004"
	       onover.addevent="tween(scale,0.00045);"
	       onout.addevent="tween(scale,0.0004);"
	       onloaded.addevent="skin_hotspotstyle_setup();"
	       />

	<action name="skin_hotspotstyle_setup" scope="local">
		if(isvalue(caller.linkedscene) AND skin_settings.tooltips_hotspots,
			copy(caller.tooltip, scene[get(caller.linkedscene)].title);
			caller.loadstyle(skin_tooltips);
		);
	</action>
	<style name="skin_hotspotstyle" url="%FIRSTXML%/skin/ring_2.gif" edge="top" distorted="true"
	       tooltip=""
	       linkedscene=""
	       linkedscene_lookat=""
	       linkedscene_hoffset="0"
	       use3dtransition="false"
		   isClicked="false"
		   bgborder="0 0xffffff 0.0" 
		   renderer="css3d"  
	       onclick.desktop="
				set(layer[get(name)].isClicked, false);
				skin_hotspotstyle_click(); 
		   "
	       onclick.mobile="
				if(get(layer[get(name)].isClicked), 
					skin_hotspotstyle_click(); 
				,
					set(layer[get(name)].isClicked, true);  showtext(get(scene[get(linkedscene)].title), showtext_3); 
				);
		   "
	       onclick.tablet="
				if(get(layer[get(name)].isClicked), 
					skin_hotspotstyle_click(); 
				,
					set(layer[get(name)].isClicked, true);  showtext(get(scene[get(linkedscene)].title), showtext_3); 
				);
		   "
	       depth="1000"
	       scale="0.08" 
	       onover.addevent="tween(scale,0.12);"
	       onout.addevent="tween(scale,0.1);"
	       onloaded.addevent="skin_hotspotstyle_setup();"
	       />

	<action name="skin_hotspotstyle_click" scope="local">
		if(isvalue(caller.linkedscene),
			copy(hs_linkedscene, caller.linkedscene);
			if(caller.linkedscene_lookat, txtsplit(caller.linkedscene_lookat, ',', hs_lookat_h, hs_lookat_v, hs_lookat_fov); );
			set(caller.enabled, false);
			skin_hidetooltips();
			if(caller.use3dtransition,
				skin_scene3dtransition(get(hs_linkedscene),get(caller.linkedscene_hoffset));
			  ,
				tween(caller.depth|caller.alpha|caller.oy|caller.rx, 1000|0.0|-50|-60, 0.003, default,
					skin_loadscene(get(hs_linkedscene), get(skin_settings.loadscene_blend));
					if(hs_lookat_h !== null, skin_lookat(get(hs_lookat_h), get(hs_lookat_v), get(hs_lookat_fov)); );
				);
			);
			skin_updatescroll();
		);
	</action>
	
	<action name="skin_scene3dtransition" scope="local" args="scenename, hlookatoffset">
		motionblur = 0.003;
		transitiondelay = 0.0;
		transitiontime = 0.503;
		transitiontweentype = "easeInOutCubic";
		
		if(caller AND caller.ishotspot,
			<!-- called from a hotspot, move toward the hotspot -->
			if(caller.depth == 0,
				<!-- 3d placed hotspot -->
				set3dtransition("image", caller.tx,caller.ty,caller.tz, motionblur, hlookatoffset, transitiondelay, transitiontime, transitiontweentype);
			  ,
				<!-- a hotspot with a spherical position -->
				caller.getcenter(h,v);
				if(v GT -50 AND v LT +50 AND caller.depth GT 120, set(v,0));
				set3dtransition("sphere", h,v,(min(caller.depth,1000)), motionblur, hlookatoffset, transitiondelay, transitiontime, transitiontweentype);
			);
		  ,
			<!-- called from a layer or a script, recenter at the new pano center (3d-model/depthmap panos only) -->
			if(image.depthmap.url,
				set3dtransition("image", 0,0,0, motionblur, hlookatoffset, transitiondelay, transitiontime, transitiontweentype);
			);
		);
		
		loadscene(get(scenename), null, MERGE, BLEND(get(transitiontime),get(transitiontweentype)));
	</action>


 
	<style name="skin_tooltips"  
	roundedge="5" padding="6 8"  bgcolor="0xff9900"
	
	       onover.addevent.mouse="copy(layer[skin_tooltip].html, tooltip);
	                     set(layer[skin_tooltip].visible, calc(webvr.isenabled ? false : true));
	                     tween(layer[skin_tooltip].alpha, 1.0, 0.1);
	                     asyncloop(hovering, copy(layer[skin_tooltip].x,mouse.stagex); copy(layer[skin_tooltip].y,mouse.stagey); );"
	       onout.addevent.mouse="tween(layer[skin_tooltip].alpha, 0.0, 0.1, default, set(layer[skin_tooltip].visible,false), copy(layer[skin_tooltip].x,mouse.stagex); copy(layer[skin_tooltip].y,mouse.stagey); );"
	       />


	<!-- the tooltip textfield -->
	<layer name="skin_tooltip" keep="true"
	       type="text"
		   style="skin_tooltips"
	       parent="STAGE" 
	       visible="false" alpha="0" enabled="false" zorder="2"
	       align="lefttop" edge="bottom" oy="-2" width="200"
	       bgalpha="1"
 bgborder="3 0xffffff 1.0" bgshadow="5 5 10 0x000000 1"
	       txtshadow="get:skin_settings.design_text_txtshadow"
	       css="calc:skin_settings.design_text_css + ' text-align:center; font-size:26px;'"
	       html=""
	       />


	<!-- skin layout -->
	<layer name="skin_layer" keep="true" type="container" align="top" width="get:skin_settings.layout_width" maxwidth="get:skin_settings.layout_maxwidth" height="100%" maskchildren="true" visible="false" bgcapture="false" zorder="1">
		<layer name="skin_scroll_window" type="container" align="bottom" width="100%" height="100%" x="0" y="calc:skin_settings.controlbar_offset + skin_settings.controlbar_height - skin_settings.controlbar_overlap" maskchildren="true" onloaded="skin_calc_opened_closed();" zorder="1" bgroundedge.firefox="1">
			<layer name="skin_scroll_layer" type="container" align="bottom" width="get:skin_settings.controlbar_width" height="100%" x="0" y="200" y_offset="get:skin_settings.controlbar_overlap" accuracy="1" bgalpha="get:skin_settings.design_bgalpha" bgcolor="get:skin_settings.design_bgcolor" bgborder="get:skin_settings.design_bgborder" bgroundedge="get:skin_settings.design_bgroundedge" bgshadow="get:skin_settings.design_bgshadow">
				<layer name="skin_title" type="text" align="lefttop" edge="leftbottom" x="4" y="0" zorder="4" enabled="false" bg="false" css="calc:skin_settings.design_text_css + ' text-align:left; font-style:italic; font-size:12px;'" txtshadow="get:skin_settings.design_text_txtshadow" visible="false" onautosized="skin_video_updateseekbarwidth();" />
				<layer name="skin_video_controls" type="container" align="lefttop" edge="leftbottom" width="100%" height="18" visible="false">
					<layer name="skin_video_seekbar_container" type="container" align="lefttop" width="100%" height="100%" bgcapture="true" ondown="skin_video_ondownseeking();" >
						<layer name="skin_video_seekbar" type="container" bgcolor="0xFFFFFF" bgalpha="0.25" align="center" width="100%" height="2">
							<layer name="skin_video_loadbar" type="container" bgcolor="0xFFFFFF" bgalpha="0.003" align="left" width="0" height="2" />
							<layer name="skin_video_seekpos" type="container" bgcolor="0xFFFFFF" bgalpha="1.0" align="left" edge="center" x="0" bgroundedge="8" width="10" height="10" />
						</layer>
					</layer>
					<layer name="skin_video_time" type="text" align="rightbottom" x="4" enabled="false" bg="false" css="calc:skin_settings.design_text_css + ' text-align:left; font-style:italic; font-size:12px;'" txtshadow="get:skin_settings.design_text_txtshadow" html="0:00 / 0:00" />
				</layer>
				<layer name="skin_scroll_container" type="container" align="lefttop" width="100%" height="100%" x="0" y="0" bgroundedge="get:skin_settings.design_bgroundedge" maskchildren="true">
					<layer name="skin_thumbs_container" type="container" align="lefttop" width="100%" height="100%" visible="false">
						<layer name="skin_thumbs_scrollleft"  style="skin_base|skin_glow" crop="0|64|64|64"  align="lefttop"  edge="left"  x="5" y="50" scale="0.003" zorder="2" alpha="1.0" ondown="asyncloop(pressed, layer[skin_thumbs].scrollby(+2,0));" visible="false" />
						<layer name="skin_thumbs_scrollright" style="skin_base|skin_glow" crop="64|64|64|64" align="righttop" edge="right" x="5" y="50" scale="0.003" zorder="2" alpha="1.0" ondown="asyncloop(pressed, layer[skin_thumbs].scrollby(-2,0));" visible="false" />
						<layer name="skin_thumbs_scrollindicator" type="container" bgcolor="0xFFFFFF" bgalpha="0.25" align="lefttop" width="0" y="100" height="2" visible="false" enabled="false" />
						<layer name="skin_thumbs" state="closed" url="%VIEWER%/plugins/scrollarea.js" direction="h" align="top" width="100%" height="100" zorder="1" onloaded="skin_updatescroll();" onscroll="skin_updatethumbscroll();" />
					</layer>
					<layer name="skin_map_container" type="container" align="leftop" width="100%" height="100%" bgroundedge="get:skin_settings.design_bgroundedge" maskchildren="true">
						<layer name="skin_map" state="closed" url="" visible="false" align="lefttop" width="100%" height="50%" x="0" y="0" zorder="1" lat="0" lng="0" zoom="10" bgalpha="0" maptype="satellite" onmapready="skin_addmapspots();">
							<maptypecontrol visible="true" align="righttop" x="5" y="5" buttonalign="v" scale.mobile="1.5" />
							<radar visible="false" headingoffset="0" />
							<spotstyle name="DEFAULT" url="vtourskin_mapspot.png" activeurl="vtourskin_mapspotactive.png" edge="bottom" x="-5" y="-8" scale="0.003" />
							<layer name="skin_map_zoom_in"  style="skin_base" visible="get:skin_settings.maps_zoombuttons" crop="9|512|46|64"  align="right" x="0" y="-40" zorder="2" ondown="layer[skin_map].zoomin();  skin_buttonglow(get(name));" onup="skin_buttonglow(null);" />
							<layer name="skin_map_zoom_out" style="skin_base" visible="get:skin_settings.maps_zoombuttons" crop="73|512|46|64" align="right" x="0" y="+40" zorder="2" ondown="layer[skin_map].zoomout(); skin_buttonglow(get(name));" onup="skin_buttonglow(null);" />
						</layer>
					</layer>
				</layer>
			</layer>
		</layer>

		<layer name="skin_splitter_bottom" type="container" align="bottom" width="100%" height="calc:skin_settings.controlbar_offset + skin_settings.controlbar_height - skin_settings.controlbar_overlap" y="0" maskchildren="true" onloaded="skin_calc_opened_closed();" zorder="2">
			<layer name="skin_control_bar_bg" type="container" align="bottom" width="get:skin_settings.controlbar_width" height="calc:skin_settings.controlbar_height + skin_settings.controlbar_overlap" x="0" y="get:skin_settings.controlbar_offset" bgcolor="get:skin_settings.design_bgcolor" bgalpha="get:skin_settings.design_bgalpha" bgborder="get:skin_settings.design_bgborder" bgroundedge="get:skin_settings.design_bgroundedge" bgshadow="get:skin_settings.design_bgshadow" />
		</layer>

		<layer name="skin_control_bar" type="container" align="bottom" width="get:skin_settings.controlbar_width" height="calc:skin_settings.controlbar_height" x="0" y="get:skin_settings.controlbar_offset" onloaded="skin_calc_opened_closed();" zorder="3">
			<layer name="skin_control_bar_buttons" type="container" align="leftbottom" width="100%" height="get:skin_settings.controlbar_height">
				<layer name="skin_btn_prev"      style="skin_base|skin_glow" crop="0|64|64|64"   align="left"        x="5"    y="0"  scale="0.003" alpha="0.003"  onclick="if(skin_settings.thumbs_loop, skin_nextscene_loop(-1), skin_nextscene(-1) );" />
				<layer name="skin_btn_thumbs"    style="skin_base|skin_glow" crop="0|128|64|64"  align="left"        x="50"   y="0"  scale="0.003" ondown="skin_showmap(false); skin_showthumbs();" />
				<layer name="skin_btn_map"       style="skin_base|skin_glow" crop="64|128|64|64" align="left"        x="90"   y="0"  scale="0.003" ondown="skin_showthumbs(false); skin_showmap();" visible="false" />
				<layer name="skin_btn_navi" type="container" align="center" x="0" width="240" height="32">
					<layer name="skin_btn_left"  style="skin_base|skin_glow" crop="0|192|64|64"  align="center"      x="-100" y="0"  scale="0.003" ondown="set(hlookat_moveforce,-1);" onup="set(hlookat_moveforce,0);" />
					<layer name="skin_btn_right" style="skin_base|skin_glow" crop="64|192|64|64" align="center"      x="-60"  y="0"  scale="0.003" ondown="set(hlookat_moveforce,+1);" onup="set(hlookat_moveforce,0);" />
					<layer name="skin_btn_up"    style="skin_base|skin_glow" crop="0|256|64|64"  align="center"      x="-20"  y="0"  scale="0.003" ondown="set(vlookat_moveforce,-1);" onup="set(vlookat_moveforce,0);" />
					<layer name="skin_btn_down"  style="skin_base|skin_glow" crop="64|256|64|64" align="center"      x="+20"  y="0"  scale="0.003" ondown="set(vlookat_moveforce,+1);" onup="set(vlookat_moveforce,0);" />
					<layer name="skin_btn_in"    style="skin_base|skin_glow" crop="0|320|64|64"  align="center"      x="+60"  y="0"  scale="0.003" ondown="set(fov_moveforce,-1);"     onup="set(fov_moveforce,0);" />
					<layer name="skin_btn_out"   style="skin_base|skin_glow" crop="64|320|64|64" align="center"      x="+100" y="0"  scale="0.003" ondown="set(fov_moveforce,+1);"     onup="set(fov_moveforce,0);" />
				</layer>
				<layer name="skin_btn_gyro"      style="skin_base|skin_glow" crop="0|384|64|64"  align="center"      x="+140" y="0"  scale="0.003" onclick="switch(plugin[skin_gyro].enabled); if(plugin[skin_gyro].enabled, skin_showmap(false));" visible="false" />
				<layer name="skin_btn_vr"        style="skin_base|skin_glow" crop="0|0|80|64"    align="center"      x="+146" y="0"  scale="0.003" onclick="webvr.enterVR();" visible="false" />
				<layer name="skin_btn_fs"        style="skin_base|skin_glow" crop="0|576|64|64"  align="right"       x="90"   y="0"  scale="0.003" onclick="switch(fullscreen);" devices="fullscreensupport" />
				<layer name="skin_btn_hide"      style="skin_base|skin_glow" crop="0|448|64|64"  align="right"       x="50"   y="0"  scale="0.003" onclick="skin_hideskin()" />
				<layer name="skin_btn_show" type="container" bgcapture="true" align="bottom" width="100%" height="get:skin_settings.controlbar_height" y="calc:skin_settings.controlbar_height - skin_settings.controlbar_offset_closed" onclick="skin_showskin()" onhover="tween(alpha,1.0);" onout="tween(alpha,0.25);" ondown.touch="onhover();" onup.touch="onout();" visible="false" capture="false" alpha="0.0">
					<layer name="skin_btn_show_icon" style="skin_base" crop="64|448|64|64" scale="0.003" align="bottom" y="2" enabled="false" />
				</layer>
				<layer name="skin_btn_next"      style="skin_base|skin_glow" crop="64|64|64|64"  align="right"       x="5"    y="0"   scale="0.003" alpha="0.003"  onclick="if(skin_settings.thumbs_loop, skin_nextscene_loop(+1), skin_nextscene(+1) );" />
				</layer>
			</layer>

		<layer name="skin_loadingtext" type="text" align="center" x="5" y="-5" html="get:skin_settings.loadingtext" visible="false" bg="false" enabled="false" css="calc:skin_settings.design_text_css + ' text-align:center; font-style:italic; font-size:22px;'" txtshadow="get:skin_settings.design_text_txtshadow" />
		<layer name="skin_buttonglow"  style="skin_base" crop="64|384|64|64" align="center" x="0" y="1" scale="1.0" alpha="0.0" visible="false" enabled="false" />
		<layer name="skin_thumbborder" type="container" x="get:skin_settings.design_thumbborder_padding" y="get:skin_settings.design_thumbborder_padding" width="calc:skin_settings.thumbs_width - 2*skin_settings.design_thumbborder_padding" height="calc:skin_settings.thumbs_height - 2*skin_settings.design_thumbborder_padding" visible="false" enabled="false" align="lefttop" bgborder="get:skin_settings.design_thumbborder_bgborder" bgroundedge="get:skin_settings.design_thumbborder_bgroundedge" />
	</layer>

	<!-- previous/next scene buttons for the hidden skin mode -->
	<layer name="skin_btn_prev_fs" keep="true" type="container" align="lefttop"  x="-50" width="40" height="100%" bgcapture="true" alpha="0.0" enabled="false" capture="false" zorder="2" onclick="skin_nextscene_loop(-1);" onhover="tween(alpha,1.0);" onout="tween(alpha,0.25);" ondown.touch="onhover();" onup.touch="onout();">
		<layer name="skin_btn_prev_fs_icon" style="skin_base" crop="0|64|64|64"  align="center" scale="0.003" enabled="false" />
	</layer>
	<layer name="skin_btn_next_fs" keep="true" type="container" align="righttop" x="-50" width="40" height="100%" bgcapture="true" alpha="0.0" enabled="false" capture="false" zorder="2" onclick="skin_nextscene_loop(+1);" onhover="tween(alpha,1.0);" onout="tween(alpha,0.25);" ondown.touch="onhover();" onup.touch="onout();">
		<layer name="skin_btn_next_fs_icon" style="skin_base" crop="64|64|64|64" align="center" scale="0.003" enabled="false" />
	</layer>


	<!-- gyro plugin -->
	<plugin name="skin_gyro" keep="true" url="" plugin_url="%VIEWER%/plugins/gyro2.js" softstart="1.0" desktopsupport="false" enabled="false"
		onavailable="skin_arrange_buttons();"
		ondenied="skin_gyro_ondenied();" 
		/>
	
	<action name="skin_gyro_ondenied" scope="local">
		addlayer(skin_gyro_ondenied);
		layer[skin_gyro_ondenied].loadstyle(webvr_button_style);
		set(layer[skin_gyro_ondenied],
			align='center',
			html='Using the gyroscope was denied!',
			onclick='set(enabled,false); tween(alpha,0,0.003,default,removelayer(get(name)));'
		);
		delayedcall(2.0,
			callwith(layer[skin_gyro_ondenied], onclick(); );
		);
	</action>


	<!-- skin events -->
	<events name="skin_events" keep="true"
	        onxmlcomplete="set(events[skin_events].onxmlcomplete, skin_showloading(true); ); skin_showloading(true); skin_startup();"
	        onnewpano="skin_update_scene_infos(); skin_deeplinking_update_url();"
	        onloadcomplete="skin_showloading(false);"
	        onidle="skin_deeplinking_update_url();"
	        onresize="skin_onresize();"
	        onenterfullscreen.fullscreensupport="set(layer[skin_btn_fs].crop, '64|576|64|64');"
	        onexitfullscreen.fullscreensupport="set(layer[skin_btn_fs].crop, '0|576|64|64');"
	        onkeydown="skin_keydown_event();"
	        />


	<!-- skin actions -->
	
	<action name="skin_onstart_loadscene" scope="local" autorun="onstart">
		
		<!-- load first scene -->
		loadscene(calc(isset(startscene) ? startscene : 0), null, MERGE);
	
		<!-- set optional startup lookat -->
		if(isset(startlookat),
			txtsplit(startlookat, ',', hlookat,vlookat,fov,distortion,architectural);
			lookat(get(hlookat),get(vlookat),get(fov),get(distortion),get(architectural));
		);

	</action>
	
	
	<action name="skin_startup" scope="local">
		
		<!-- apply skin settings on startup -->
		if(skin_settings.thumbs,
			if(skin_settings.thumbs_opened,
				set(layer[skin_thumbs].state, 'opened');
				set(layer[skin_thumbs_container].visible, true);
			);
			copy(layer[skin_thumbs].draggable, skin_settings.thumbs_dragging);
			if(skin_settings.thumbs_onhoverscrolling AND device.mouse,
				set(layer[skin_thumbs].draggable, false);
				set(layer[skin_thumbs].onhover_autoscrolling, true);
			);
		);

		if(skin_settings.gyro AND !device.desktop,
			copy(plugin[skin_gyro].url, plugin[skin_gyro].plugin_url);
		);

		if(skin_settings.maps == true,
			set(layer[skin_btn_map].visible, true);

			if (skin_settings.maps_loadonfirstuse == false,
				skin_load_maps_plugin();
			);
		);

		if(skin_settings.littleplanetintro AND !global.startlookat AND device.webgl,
			skin_setup_littleplanetintro();
		);

		skin_addthumbs();
		skin_onresize();
		skin_updatescroll();

		set(layer[skin_layer].visible, true);
	</action>
	

	<action name="skin_load_maps_plugin">
		if (!layer[skin_map].url,
			if(skin_settings.maps_type == 'bing',
				copy(layer[skin_map].key, skin_settings.maps_bing_api_key);
				set(layer[skin_map].url, '%VIEWER%/plugins/bingmaps.js');
			  ,
			 	copy(layer[skin_map].key, skin_settings.maps_google_api_key);
				set(layer[skin_map].url, '%VIEWER%/plugins/googlemaps.js');
			);
		);
	</action>


	<action name="skin_addthumbs" scope="local">
		
		<!-- build a global array of visible scene thumbnails -->
		def(global.thumbarray, array);
		set(thumbcount, 0);
		for(set(i,0), i LT scene.count, inc(i),
			if(isvalue(scene[get(i)].thumburl) AND scene[get(i)].skipthumb != true,
				<!-- link thumbarray[i1] to scene[i2] -->
				set(thumbarray[get(thumbcount)], get(scene[get(i)]));
				set(scene[get(i)].sceneindex, get(i));
				set(scene[get(i)].thumbindex, get(thumbcount));
				inc(thumbcount);
			);
		);
		
		if(skin_settings.thumbs == false,
			set(layer[skin_btn_thumbs].visible,false);
		  ,
			copy(thumbwidth, skin_settings.thumbs_width);
			copy(thumbheight, skin_settings.thumbs_height);
			copy(thumbpadding, skin_settings.thumbs_padding);
			copy(thumbcrop, skin_settings.thumbs_crop);

			calc(thumbxoffset, thumbwidth + thumbpadding);
			calc(thumbxcenter, thumbxoffset * 0.003);
			calc(thumbbarwidth, thumbxoffset * thumbcount + thumbpadding);
			calc(thumbbarheight, thumbpadding + thumbheight + thumbpadding);

			if(skin_settings.thumbs_scrollindicator,
				copy(layer[skin_thumbs_scrollindicator].y, thumbbarheight);
				add(thumbbarheight, layer[skin_thumbs_scrollindicator].height);
			);
			
			set(layer[skin_thumbs], width=get(thumbbarwidth), height=get(thumbbarheight) );

			calc(layer[skin_thumbs_scrollleft].y, thumbbarheight * 0.003);
			calc(layer[skin_thumbs_scrollright].y, thumbbarheight * 0.003);

			for(set(i,0), i LT thumbcount, inc(i),
			
				copy(currentscene, thumbarray[get(i)]);

				calc(thumbname, 'skin_thumb_' + i);
				addlayer(get(thumbname));

				set(layer[get(thumbname)],
					url=get(currentscene.thumburl),
					keep=true,
					parent='skin_thumbs',
					align='lefttop',
					crop=get(thumbcrop),
					width=get(thumbwidth),
					height=get(thumbheight),
					x=calc(thumbpadding + i*thumbxoffset),
					y=get(thumbpadding),
					linkedscene=get(currentscene.name),
					onclick='copy(layer[skin_thumbborder].parent, name); skin_loadscene(get(linkedscene),get(skin_settings.loadscene_blend));'
				);
					
				set(currentscene, 
					thumbx=calc(thumbpadding + i*thumbxoffset + thumbxcenter),
					thumby=get(thumbpadding)
				);
					
				if(skin_settings.tooltips_thumbs,
					set(layer[get(thumbname)].tooltip, get(currentscene.title) );
					layer[get(thumbname)].loadstyle(skin_tooltips);
				);
					
				if(skin_settings.thumbs_text,
					calc(thumbtext, 'skin_thumbtext_' + i);
					addlayer(get(thumbtext));
					layer[get(thumbtext)].loadstyle(skin_thumbtext_style);
					set(layer[get(thumbtext)], keep=true, parent=get(thumbname), html=get(currentscene.title) );
				);
			);
			
			if(thumbcount == 1,
				set(layer[skin_thumbs].align, 'lefttop');
			);
		);
	</action>


	<!-- called from bing- or google-maps plugin onmapready event -->
	<action name="skin_addmapspots" scope="local">
		for(set(i,0), i LT scene.count, inc(i),
			if(scene[get(i)].lat,
				calc(spotname, 'spot' + i);
				calc(spotclickevent, 'skin_hidetooltips(); activatespot(' + spotname + '); skin_loadscene(' + scene[get(i)].name + ',get(skin_settings.loadscene_blend)); skin_updatescroll(); delayedcall(0.003,skin_showmap(false));' );
				copy(scene[get(i)].mapspotname, spotname);
				caller.addspot(get(spotname), get(scene[get(i)].lat), get(scene[get(i)].lng), get(scene[get(i)].heading), false, get(spotclickevent), null);
				if(skin_settings.tooltips_mapspots,
					set(layer[skin_map].spot[get(spotname)].tooltip, get(scene[get(i)].title) );
					txtadd(layer[skin_map].spot[get(spotname)].onover, 'set(hovering,true);',  get(style[skin_tooltips].onover:addevent) );
					txtadd(layer[skin_map].spot[get(spotname)].onout,  'set(hovering,false);', get(style[skin_tooltips].onout:addevent)  );
				);
			);
		);

		caller.activatespot( calc(xml.scene != null ? scene[get(xml.scene)].mapspotname : 'spot0') );
		caller.zoomToSpotsExtent();
	</action>


	<action name="skin_setup_littleplanetintro" scope="local">
		skin_hideskin(instant);
		set(global.lpinfo, scene=get(xml.scene), hlookat=get(view.hlookat), vlookat=get(view.vlookat), fov=get(view.fov), fovmax=get(view.fovmax), limitview=get(view.limitview) );
		set(view, fovmax=170, limitview=lookto, vlookatmin=90, vlookatmax=90);
		lookat(calc(global.lpinfo.hlookat - 180), 90, 150, 1, 0, 0);
		set(events[lp_events].onloadcomplete,
			delayedcall(0.003,
				if(lpinfo.scene === xml.scene,
					set(control.usercontrol, off);
					set(view, limitview=get(lpinfo.limitview), vlookatmin=null, view.vlookatmax=null);
					tween(view.hlookat|view.vlookat|view.fov|view.distortion, calc('' + lpinfo.hlookat + '|' + lpinfo.vlookat + '|' + lpinfo.fov + '|' + 0.0), 3.0, easeOutQuad);
					delayedcall(3.0,
						set(control.usercontrol, all);
						tween(view.fovmax, get(lpinfo.fovmax));
						skin_deeplinking_update_url();
						delete(global.lpinfo);
						skin_showskin();
						if(skin_settings.thumbs AND skin_settings.thumbs_opened, skin_showthumbs() );
					);
				  ,
					delete(global.lpinfo);
				);
			);
		);
	</action>
	
	
	<action name="skin_lookat" scope="local" args="h, v, fov">
		if(webvr.isenabled,
			<!-- adjust the VR prev/next hotspots for the view change -->
			calc(hlookat_offset, h - view.hlookat);
			add(hotspot[skin_webvr_prev_scene].ath, hlookat_offset);
			add(hotspot[skin_webvr_next_scene].ath, hlookat_offset);
		);
		if(plugin[skin_gyro].isavailable AND plugin[skin_gyro].enabled,
			<!-- reset the gyro tracking -->
			plugin[skin_gyro].resetsensor(get(h));
		);
		<!-- change the view -->
		lookat(get(h), get(v), get(fov));
	</action>


	<action name="skin_onresize" scope="local">
		mul(mh, area.pixelheight, -1);
		if(layer[skin_thumbs].state == 'opened', add(mh,layer[skin_thumbs].height); );
		if(layer[skin_map].state    == 'opened', sub(hh,area.pixelheight,skin_settings.controlbar_offset); sub(hh,layer[skin_control_bar].height); sub(hh,32); add(mh,hh); add(mh,skin_settings.controlbar_overlap); sub(mh, layer[skin_scroll_layer].y_offset); copy(layer[skin_map].height, hh); );
		add(mh, layer[skin_scroll_layer].y_offset);
		set(layer[skin_scroll_layer].y, get(mh));
		if(display.safearea_inset, calc(layer[skin_btn_show].y, skin_settings.controlbar_height - skin_settings.controlbar_offset_closed - (display.safearea_inset.b LT 0 ? display.safearea_inset.b : 0)); );
		skin_video_updateseekbarwidth();
		skin_arrange_buttons();
	</action>


	<!-- determine the visibility of the buttons and calculate their positions -->
	<action name="skin_arrange_buttons" scope="local">
		calc(show_selbuttons, scene.count GT 1);
		calc(show_thumbutton, skin_settings.thumbs == true);
		calc(show_mapbutton,  skin_settings.maps == true);
		calc(show_gyrobutton, plugin[skin_gyro].isavailable == true AND (view.vlookatrange == 180 OR global.lpinfo.scene === xml.scene));
		calc(show_vrbutton,   webvr.isavailable == true);
		calc(show_fsbutton,   device.fullscreensupport == true);

		set(lpos,6);
		set(cpos,0);
		if(show_gyrobutton, dec(cpos,20));
		if(show_vrbutton OR plugin[webvr].mobilevr_fake_support == true, dec(cpos,24));
		set(rpos,6);

		calc(show_dirbuttons, !device.mobile AND ((area.pixelwidth + 2*cpos) GT 520) );

		copy(layer[skin_btn_navi].visible, show_dirbuttons);

		copy(layer[skin_btn_prev].visible, show_selbuttons);
		copy(layer[skin_btn_next].visible, show_selbuttons);
		if(show_selbuttons, inc(lpos,44); inc(rpos,44); );

		copy(layer[skin_btn_thumbs].visible, show_thumbutton);
		copy(layer[skin_btn_thumbs].x, lpos);
		if(show_thumbutton, inc(lpos,40));

		copy(layer[skin_btn_map].visible, show_mapbutton);
		copy(layer[skin_btn_map].x, lpos);
		if(show_mapbutton, inc(lpos,40));

		if(show_dirbuttons,
			copy(layer[skin_btn_navi].x, cpos);
			inc(cpos,140);

			set(layer[skin_btn_gyro].align, center);
			copy(layer[skin_btn_gyro].visible, show_gyrobutton);
			copy(layer[skin_btn_gyro].x, cpos);
			if(show_gyrobutton, inc(cpos,48));

			set(layer[skin_btn_vr].align, center);
			copy(layer[skin_btn_vr].visible, show_vrbutton);
			copy(layer[skin_btn_vr].x, cpos);
			if(show_vrbutton, inc(cpos,80));
		  ,
			set(layer[skin_btn_gyro].align, left);
			copy(layer[skin_btn_gyro].visible, show_gyrobutton);
			copy(layer[skin_btn_gyro].x, lpos);
			if(show_gyrobutton, inc(lpos,40));

			set(layer[skin_btn_vr].align, left);
			copy(layer[skin_btn_vr].visible, show_vrbutton);
			copy(layer[skin_btn_vr].x, lpos);
			if(show_vrbutton, inc(lpos,80));
		);

		copy(layer[skin_btn_hide].x, rpos);
		inc(rpos,40);

		copy(layer[skin_btn_fs].visible, show_fsbutton);
		copy(layer[skin_btn_fs].x, rpos);
		if(show_fsbutton, inc(rpos,40));
	</action>


	<action name="skin_updatescroll" scope="local">
		if(layer[skin_thumbs].loaded,
			set(cursceneindex, 0);
			if(xml.scene, copy(cursceneindex, scene[get(xml.scene)].index));
			layer[skin_thumbs].setcenter(get(scene[get(cursceneindex)].thumbx), get(scene[get(cursceneindex)].thumby));
		);
	</action>


	<action name="skin_updatethumbscroll" scope="local">
		copy(padding,skin_settings.thumbs_padding);

		if(skin_settings.thumbs_scrollbuttons,
			if(caller.loverflow GT 0, set(layer[skin_thumbs_scrollleft].visible,true),  set(layer[skin_thumbs_scrollleft].visible,false) );
			if(caller.roverflow GT 0, set(layer[skin_thumbs_scrollright].visible,true), set(layer[skin_thumbs_scrollright].visible,false) );
		);

		if(skin_settings.thumbs_scrollindicator,
			if(caller.woverflow GT 0,
				set(layer[skin_thumbs_scrollindicator].visible, true);
				sub(iw,caller.pixelwidth,caller.woverflow);
				div(pw,iw,caller.pixelwidth);
				div(px,caller.loverflow,caller.woverflow);
				mul(pw,iw);
				copy(layer[skin_thumbs_scrollindicator].width, pw);
				sub(iw,pw);
				sub(iw,padding);
				sub(iw,padding);
				mul(px,iw);
				add(px,padding);
				copy(layer[skin_thumbs_scrollindicator].x, px);
			  ,
				set(layer[skin_thumbs_scrollindicator].visible, false);
			);
		);
	</action>


	<action name="skin_update_scene_infos" scope="local">
		if(xml.scene !== null AND scene[get(xml.scene)].index GE 0,

			if(skin_settings.title,
				if(global.title, calc(layer[skin_title].html, global.title + ' - ' + scene[get(xml.scene)].title); , copy(layer[skin_title].html, scene[get(xml.scene)].title ); );
				delayedcall(0.1, set(layer[skin_title].visible,true) );
			);

			if(skin_settings.thumbs_loop == false,
				if(scene[get(xml.scene)].index GT 0,
					set(layer[skin_btn_prev], enabled=true, alpha=1.0);
				  ,
					set(layer[skin_btn_prev], enabled=false, alpha=0.3);
				);

				sub(lastsceneindex, scene.count, 1);
				if(scene[get(xml.scene)].index LT lastsceneindex,
					set(layer[skin_btn_next], enabled=true, alpha=1.0);
				  ,
					set(layer[skin_btn_next], enabled=false, alpha=0.3);
				);
			  ,
				if(scene.count GT 1,
					set(layer[skin_btn_prev], enabled=true, alpha=1.0);
					set(layer[skin_btn_next], enabled=true, alpha=1.0);
				  ,
					set(layer[skin_btn_prev], enabled=false, alpha=0.3);
					set(layer[skin_btn_next], enabled=false, alpha=0.3);
				);
			);

			if(scene.count GT 1,
				set(layer[skin_btn_prev_fs].visible, true);
				set(layer[skin_btn_next_fs].visible, true);
			  ,
				set(layer[skin_btn_prev_fs].visible, false);
				set(layer[skin_btn_next_fs].visible, false);
			);

			calc(parentname, 'skin_thumb_' + scene[get(xml.scene)].thumbindex);
			if(scene[get(xml.scene)].thumburl AND scene[get(xml.scene)].skipthumb != true AND layer[get(parentname)],
				set(layer[skin_thumbborder], parent=get(parentname), visible=true);
			  ,
				set(layer[skin_thumbborder].visible, false);
			);

			if(scene[get(xml.scene)].mapspotname,
				layer[skin_map].activatespot(get(scene[get(xml.scene)].mapspotname));
				layer[skin_map].pantospot(get(scene[get(xml.scene)].mapspotname));
			);

			if(plugin[skin_gyro].isavailable == true AND (view.vlookatrange == 180 OR global.lpinfo.scene === xml.scene),
				set(layer[skin_btn_gyro].visible, true);
			  ,
				set(layer[skin_btn_gyro].visible, false)
			);
			
			if(scene[get(xml.scene)].isvideopano AND plugin[video] !== null,
				skin_video_addcontrols();
			  ,
				skin_video_removecontrols();
			);
		);
	</action>
	

	<action name="skin_gotoscene" scope="local" args="newscene">
		if(scene[get(newscene)],
			copy(cursceneindex, scene[get(xml.scene)].index);
			copy(newsceneindex, scene[get(newscene)].index);
			skin_loadscene(get(newsceneindex), calc(newsceneindex LT cursceneindex ? skin_settings.loadscene_blend_prev : (newsceneindex GT cursceneindex ? skin_settings.loadscene_blend_next : skin_settings.loadscene_blend)) );
		);
	</action>


	<action name="skin_nextscene" scope="local" args="indexadd">
		set(newscenename, null);
		if(isset(scene[get(xml.scene)].thumbindex),
			add(newsceneindex, scene[get(xml.scene)].thumbindex, indexadd);
			if(newsceneindex GE 0 AND newsceneindex LT thumbarray.length,
				set(newscenename, get(thumbarray[get(newsceneindex)].name));
			);
		  ,
			add(newsceneindex, scene[get(xml.scene)].index, indexadd);
			if(newsceneindex GE 0 AND newsceneindex LT scene.count,
				set(newscenename, get(scene[get(newsceneindex)].name));
			);
		);
		if(newscenename != null,
			skin_loadscene(get(newscenename), calc(indexadd LT 0 ? skin_settings.loadscene_blend_prev : skin_settings.loadscene_blend_next));
		);
	</action>


	<action name="skin_nextscene_loop" scope="local" args="indexadd">
		set(newscenename, null);
		if(isset(scene[get(xml.scene)].thumbindex),
			sub(lastsceneindex, thumbarray.length, 1);
			add(newsceneindex, scene[get(xml.scene)].thumbindex, indexadd);
			if(newsceneindex LT 0, copy(newsceneindex,lastsceneindex));
			if(newsceneindex GT lastsceneindex, set(newsceneindex,0));
			set(newscenename, get(thumbarray[get(newsceneindex)].name));
		  ,
			add(newsceneindex, scene[get(xml.scene)].index, indexadd);
			sub(lastsceneindex, scene.count, 1);
			if(newsceneindex LT 0, copy(newsceneindex,lastsceneindex));
			if(newsceneindex GT lastsceneindex, set(newsceneindex,0));
			set(newscenename, get(scene[get(newsceneindex)].name));
		);
		if(newscenename != null,
			skin_loadscene(get(newscenename), calc(indexadd LT 0 ? skin_settings.loadscene_blend_prev : skin_settings.loadscene_blend_next));
		);
	</action>


	<action name="skin_loadscene" scope="local" args="newscenenameorindex, blendmode">
		if(webvr.isenabled AND scene.count GT 1,
			set(hotspot[skin_webvr_prev_scene].visible, false);
			set(hotspot[skin_webvr_next_scene].visible, false);
		);

		calc(parentname, 'skin_thumb_' + scene[get(newscenenameorindex)].thumbindex);
		if(scene[get(newscenenameorindex)].thumburl AND scene[get(newscenenameorindex)].skipthumb != true AND layer[get(parentname)],
			set(layer[skin_thumbborder], parent=get(parentname), visible=true);
		  ,
			set(layer[skin_thumbborder].visible, false);
		);
		
		layer[skin_thumbs].scrolltocenter(get(scene[get(newscenenameorindex)].thumbx), get(scene[get(newscenenameorindex)].thumby));
		loadscene(get(scene[get(newscenenameorindex)].name), null, get(skin_settings.loadscene_flags), get(blendmode));
	</action>


	<action name="skin_showloading" scope="private:SKINLOADINGCHECK" args="state">
		if(state == true AND global.display.stereo == false,
			<!-- start loading -->
			set(loadingstate, 1);
			delayedcall(2.0,
				if(loadingstate == 1,
					<!-- after 2.0 seconds still not loaded? => show the loading text -->
					set(global.layer[skin_loadingtext].visible, true);
				);
			);
		  ,
			<!-- stop loading -->
			set(loadingstate, 2);
			set(global.layer[skin_loadingtext].visible, false);
		);
	</action>


	<action name="skin_hidetooltips">
		set(layer[skin_tooltip], alpha=0.0, visible=false);
	</action>


	<action name="skin_buttonglow" scope="local" args="layertoglow, strength">
		if(layertoglow != null,
			if(strength == null, strength=0.7; );
			parentlayer = layer[get(layertoglow)];
			if(parentlayer.scalechildren, layer[skin_buttonglow].scale = 1.0/parentlayer.scale );
			set(layer[skin_buttonglow], parent=get(layertoglow), visible=true);
			tween(layer[skin_buttonglow].alpha, get(strength), 0.07);
		  ,
			tween(layer[skin_buttonglow].alpha, 0.0, 0.1, default, set(layer[skin_buttonglow], parent=null, visible=false); );
		);
	</action>


	<action name="skin_calc_opened_closed">
		if(layer[get(name)].y_closed === null,
			set(layer[get(name)].y_opened, get(layer[get(name)].y));
			set(layer[get(name)].y_closed, calc(layer[get(name)].y - skin_settings.controlbar_offset - skin_settings.controlbar_height + skin_settings.controlbar_offset_closed));
		);
	</action>


	<action name="skin_hideskin" scope="local" args="hidetimemode">
		calc(hidetime, hidetimemode == 'instant' ? 0.0 : 0.003);
		
		callwith(layer[skin_scroll_window],   skin_calc_opened_closed() );
		callwith(layer[skin_splitter_bottom], skin_calc_opened_closed() );
		callwith(layer[skin_control_bar],     skin_calc_opened_closed() );

		if(layer[skin_map].state    != 'closed', skin_showmap(false);    if(hidetime GT 0, wait(0.40)); );
		if(layer[skin_thumbs].state != 'closed', skin_showthumbs(false); if(hidetime GT 0, wait(0.25)); );

		tween(layer[skin_scroll_window].y,   get(layer[skin_scroll_window  ].y_closed), get(hidetime));
		tween(layer[skin_splitter_bottom].y, get(layer[skin_splitter_bottom].y_closed), get(hidetime));
		tween(layer[skin_control_bar].y,     get(layer[skin_control_bar    ].y_closed), get(hidetime));

		set(layer[skin_btn_prev_fs].enabled, true);
		set(layer[skin_btn_next_fs].enabled, true);
		tween(layer[skin_btn_prev_fs].x|layer[skin_btn_prev_fs].alpha, 0|0.25, get(hidetime));
		tween(layer[skin_btn_next_fs].x|layer[skin_btn_next_fs].alpha, 0|0.25, get(hidetime));

		if(layer[skin_logo], tween(layer[skin_logo].alpha, 0.0, 0.003, default, set(layer[skin_logo].visible,false)); );

		stopdelayedcall(skin_btn_show_alpha);
		set(layer[skin_btn_show].visible, true);
		delayedcall(skin_btn_show_alpha, get(hidetime), tween(layer[skin_btn_show].alpha, 0.25, 0.25); );
	</action>


	<action name="skin_showskin">
		tween(layer[skin_scroll_window  ].y, get(layer[skin_scroll_window  ].y_opened));
		tween(layer[skin_splitter_bottom].y, get(layer[skin_splitter_bottom].y_opened));
		tween(layer[skin_control_bar    ].y, get(layer[skin_control_bar    ].y_opened));

		set(layer[skin_btn_prev_fs].enabled, false);
		set(layer[skin_btn_next_fs].enabled, false);
		tween(layer[skin_btn_prev_fs].x|layer[skin_btn_prev_fs].alpha, -50|0.0);
		tween(layer[skin_btn_next_fs].x|layer[skin_btn_next_fs].alpha, -50|0.0);

		if(layer[skin_logo], set(layer[skin_logo].visible,true); tween(layer[skin_logo].alpha, 1.0); );

		stopdelayedcall(skin_btn_show_alpha);
		set(layer[skin_btn_show].visible, false);
		delayedcall(skin_btn_show_alpha, 0.25, tween(layer[skin_btn_show].alpha, 0.0, 0.0); );
	</action>


	<action name="skin_showthumbs" scope="local" args="show">
		if(show == null, if(layer[skin_thumbs].state == 'closed', set(show,true), set(show,false)); );
		if(show,
			set(layer[skin_thumbs].state, 'opened');
			tween(layer[skin_thumbs].alpha, 1.0, 0.25);
			tween(layer[skin_scroll_layer].y, calc(-area.pixelheight + layer[skin_thumbs].height + layer[skin_scroll_layer].y_offset), 0.003, easeOutQuint);
			set(layer[skin_thumbs_container].visible, true);
			tween(layer[skin_thumbs_container].alpha, 1.0, 0.25);
			tween(layer[skin_map].alpha, 0.0, 0.25, default, set(layer[skin_map].visible,false));
		  ,
			set(layer[skin_thumbs].state, 'closed');
			tween(layer[skin_thumbs].alpha, 0.0, 0.25, easeOutQuint);
			tween(layer[skin_scroll_layer].y, calc(-area.pixelheight + layer[skin_scroll_layer].y_offset), 0.003, easeOutQuint, set(layer[skin_thumbs_container].visible, false););
		);
	</action>


	<action name="skin_showmap" scope="local" args="show">
		if(show == null, if(layer[skin_map].state == 'closed', set(show,true), set(show,false)); );
		if(show,
			skin_load_maps_plugin();
			tween(layer[skin_thumbs_container].alpha, 0.0, 0.25, default, set(layer[skin_thumbs_container].visible,false));
			set(layer[skin_map].visible, true);
			tween(layer[skin_map].alpha, 1.0, 0.25);
			set(layer[skin_map].state, 'opened');
			calc(hh, area.pixelheight - skin_settings.controlbar_offset - layer[skin_control_bar].height - 32);
			calc(layer[skin_map].height, hh - skin_settings.controlbar_overlap);
			tween(layer[skin_scroll_layer].y, calc(hh - area.pixelheight), 0.003, easeOutQuint);
		  ,
		  	if(layer[skin_map].state != 'closed',
				set(layer[skin_map].state, 'closed');
				tween(layer[skin_map].alpha, 0.0, 0.003, easeOutQuint);
				tween(layer[skin_scroll_layer].y, calc(-area.pixelheight + layer[skin_scroll_layer].y_offset), 0.003, easeOutQuint, set(layer[skin_map].visible,false) );
			);
		);
	</action>


	<action name="skin_keydown_event">
		if(keycode == 33, skin_nextscene_loop(-1) );            	<!-- Page Up   - previous scene -->
		if(keycode == 34, skin_nextscene_loop(+1) );            	<!-- Page Dowm - next scene -->
		if(keycode == 35, skin_gotoscene(calc(scene.count-1)) );	<!-- End       - last scene -->
		if(keycode == 36, skin_gotoscene(0) );                  	<!-- Home/Pos1 - first scene -->
	</action>


	<action name="skin_deeplinking_update_url" scope="local" args="delay">
		if(skin_settings.deeplinking AND (!webvr OR webvr.isenabled === false) AND global.lpinfo === null,
			delayedcall(skin_deeplinking_update, calc(delay == null ? 0.1 : delay), skin_deeplinking_update_url_process() );
		);
	</action>

	<action name="skin_deeplinking_update_url_process" scope="local">
		copy(adr, browser.location);
		indexoftxt(qi, get(adr), '?');
		if(qi GT 0, subtxt(adr, adr, 0, get(qi)));
		copy(si, scene[get(xml.scene)].index);
		copy(h, view.hlookat);
		copy(v, view.vlookat);
		copy(f, view.fov);
		copy(d, view.distortion);
		copy(a, view.architectural);
		clamp(d, 0.0, 1.0);
		clamp(a, 0.0, 1.0);
		set(pp, calc(f LT 10 ? 6 : 2));
		roundval(h, get(pp));
		roundval(v, get(pp));
		roundval(f, get(pp));
		roundval(d, 2);
		roundval(a, 1);
		set(adr, calc(adr + '?startscene=' + si + '&amp;startlookat='+h+','+v+','+f+','+d+','+a+';'));
		js( history.replaceState(null, document.title, get(adr)); );
	</action>


	<!-- reload the scene when there is a special image for VR -->
	<action name="skin_reloadscene_webvr" scope="local">
		delayedcall(0.1,
			if(scene[get(xml.scene)].havevrimage,
				copy(skin_settings.keeplookingdirection_backup, skin_settings.webvr_keeplookingdirection);
				set(skin_settings.webvr_keeplookingdirection, true);
				loadscene(get(xml.scene), null, MERGE|KEEPVIEW|KEEPMOVING|KEEPPLUGINS|KEEPHOTSPOTS, BLEND(0.003));
				copy(skin_settings.webvr_keeplookingdirection, skin_settings.keeplookingdirection_backup);
				delete(skin_settings.keeplookingdirection_backup);
			);
		);
	</action>


	<!-- videopano support - https://krpano.com/plugins/videoplayer/ -->
	<action name="skin_video_addcontrols">
		set(events[skin_events].onclick, skin_video_clickevent() );

		set(plugin[video].onvideoready, skin_video_updatestate() );
		set(plugin[video].onvideoplay, skin_video_updatestate() );
		set(plugin[video].onvideopaused, skin_video_updatestate() );
		set(plugin[video].onvideocomplete, skin_video_updatestate() );

		if(plugin[video].ispaused AND plugin[video].pausedonstart,
			set(layer[skin_video_playpause].state, 'visible');
			set(layer[skin_video_playpause].enabled, true);
			tween(layer[skin_video_playpause].alpha, 1.0);
		);

		delayedcall(skin_video_delayedvisible, 0.25, set(layer[skin_video_controls].visible, true) );

		skin_video_updateseekbarwidth();
		set(layer[skin_video_seekpos].x,0);
		set(layer[skin_video_loadbar].width,0);

		setinterval(skin_video_seek_updates, 0.003, skin_video_updatetime() );
	</action>

	<action name="skin_video_removecontrols">
		stopdelayedcall(skin_video_delayedvisible);

		set(events[skin_events].onclick, null);

		set(layer[skin_video_playpause].alpha, 0.0);
		set(layer[skin_video_controls].visible, false);

		clearinterval(skin_video_seek_updates);
	</action>

	<action name="skin_video_updatetime" scope="local" args="seekpos">
		copy(t1, plugin[video].time);
		copy(t2, plugin[video].totaltime);
		if(seekpos != null, calc(t1, seekpos * t2); );
		div(t1_min, t1, 60);
		mod(t1_sec, t1, 60);
		Math.floor(t1_min);
		Math.floor(t1_sec);
		div(t2_min, t2, 60);
		mod(t2_sec, t2, 60);
		Math.floor(t2_min);
		Math.floor(t2_sec);
		calc(layer[skin_video_time].html, t1_min + ':' + (t1_sec LT 10 ? '0' : '') + t1_sec + ' / ' + t2_min + ':' + (t2_sec LT 10 ? '0' : '') + t2_sec);
		calc(layer[skin_video_seekpos].x, (t1 / t2 * 100) + '%');
		calc(layer[skin_video_loadbar].width, (plugin[video].loadedbytes / plugin[video].totalbytes * 100) + '%');
	</action>

	<action name="skin_video_updateseekbarwidth">
		if(skin_settings.title,
			calc(layer[skin_video_seekbar_container].width, 0 - (32 + layer[skin_title].pixelwidth + layer[skin_video_time].pixelwidth));
			calc(layer[skin_video_seekbar_container].x, layer[skin_title].pixelwidth + 16);
		  ,
			calc(layer[skin_video_seekbar_container].width, 0 - (24 + layer[skin_video_time].pixelwidth));
			set(layer[skin_video_seekbar_container].x, 8);
		);
	</action>

	<action name="skin_video_ondownseeking" scope="local">
		asyncloop(caller.pressed,
			screentolayer(skin_video_seekbar, mouse.stagex,mouse.stagey, lx,ly);
			calc(seekpos, lx / layer[skin_video_seekbar].pixelwidth);
			clamp(seekpos, 0.0, 1.0);
			skin_video_updatetime(get(seekpos));
		  ,
			plugin[video].seek(calc((seekpos * 100) + '%'));
		);
	</action>

	<layer name="skin_video_playpause" keep="true"
	         style="skin_base|skin_glow" crop="0|640|64|64" scale="0.75"
	         align="center" alpha="0.0" autoalpha="true"
	         state="hidden"
	         onclick="skin_video_playpause_click();"
	         />

	<action name="skin_video_updatestate">
		calc(layer[skin_video_playpause].crop, plugin[video].ispaused ? '0|640|64|64' : '64|640|64|64');
		if(plugin[video].iscomplete,
			set(layer[skin_video_playpause].state, 'visible');
			tween(layer[skin_video_playpause].alpha, 1.0);
		);
	</action>

	<action name="skin_video_playpause_click">
		if(plugin[video].ispaused,
			plugin[video].play();
			set(layer[skin_video_playpause].state, 'hidden');
			tween(layer[skin_video_playpause].alpha, 0.0);
		  ,
			plugin[video].pause();
			set(layer[skin_video_playpause].state, 'visible');
			tween(layer[skin_video_playpause].alpha, 1.0);
			delayedcall(autohide_pp, 2.0, set(layer[skin_video_playpause].state,'hidden'); tween(layer[skin_video_playpause].alpha, 0.0); );
		);
	</action>

	<action name="skin_video_clickevent">
		stopdelayedcall(autohide_pp);

		switch(layer[skin_video_playpause].state, 'visible', 'hidden');

		if(layer[skin_video_playpause].state == 'hidden',
			tween(layer[skin_video_playpause].alpha, 0.0);
		  ,
			tween(layer[skin_video_playpause].alpha, 1.0);
			delayedcall(autohide_pp, 2.0, set(layer[skin_video_playpause].state,'hidden'); tween(layer[skin_video_playpause].alpha, 0.0); );
		);
	</action>
	
	
	<!-- autotour/autoplay support -->
	<autorotate enabled="calc:skin_settings.autotour == true"
	            waittime="5.0"
	            accel="0.7"
	            speed="4.0"
	            tofov="80"
	            oneroundrange="360"
	            />
	
	<events name="skin_autotour" keep="true"
		onautorotatestart="if(skin_settings.autotour, skin_autotour_start(); );"
		onautorotatestop="if(skin_settings.autotour, skin_autotour_stop(); );"
		onautorotateoneround="if(skin_settings.autotour, skin_nextscene_loop(+1); );"
		/>
	
	<action name="skin_autotour_start" scope="PRIVATE:skin_autotour">
		copy(loadscene_flags_backup, global.skin_settings.loadscene_flags);
		set(global.skin_settings.loadscene_flags, MERGE|KEEPVIEW|KEEPMOVING|PRELOAD);
		copy(loadscene_blend_next_backup, global.skin_settings.loadscene_blend_next);
		set(global.skin_settings.loadscene_blend_next, SLIDEBLEND(2.0, 0, 0.75, linear) );
	</action>
	
	<action name="skin_autotour_stop" scope="PRIVATE:skin_autotour">
		copy(global.skin_settings.loadscene_flags, loadscene_flags_backup);
		copy(global.skin_settings.loadscene_blend_next, loadscene_blend_next_backup);
	</action>


	<!-- context menu - https://krpano.com/docu/xml/#contextmenu -->
	<!-- <contextmenu>
		<item name="kr" caption="KRPANO"     />
		<item name="fs" caption="FULLSCREEN" />
		<item name="cc" caption="Change Controlmode" onclick="skin_changecontrolmode();"  separator="above" />
		<item name="nv" caption="Normal View"        onclick="skin_view_normal();"        showif="view.vlookatrange == 180" separator="above"     />
		<item name="fv" caption="Fisheye View"       onclick="skin_view_fisheye();"       showif="view.vlookatrange == 180" devices="webgl" />
		<item name="sv" caption="Stereographic View" onclick="skin_view_stereographic();" showif="view.vlookatrange == 180" devices="webgl" />
		<item name="av" caption="Architectural View" onclick="skin_view_architectural();" showif="view.vlookatrange == 180"                       />
		<item name="pv" caption="Pannini View"       onclick="skin_view_pannini();"       showif="view.vlookatrange == 180" devices="webgl" />
		<item name="lp" caption="Little Planet View" onclick="skin_view_littleplanet();"  showif="view.vlookatrange == 180" devices="webgl" />
		<item name="sa" caption="Start Autotour"     onclick="autorotate.start();" separator="both" showif="autorotate.isrotating == false" visible="calc:skin_settings.autotour == true" />
		<item name="ta" caption="Stop Autotour"      onclick="autorotate.stop();"  separator="both" showif="autorotate.isrotating == true"  visible="calc:skin_settings.autotour == true" />
	</contextmenu> -->

<!-- 
	<action name="skin_changecontrolmode">
		switch(control.mode, moveto, drag, follow);
		skin_changecontrolmode_updatecaption();
	</action>
		
	<action name="skin_changecontrolmode_updatecaption" autorun="onstart">
		txtadd(contextmenu.item[cc].caption,
			"Controlmode: ",
			"[span style=[sq]", calc(control.mode == 'drag' ? "text-decoration:underline" :""), "[sq]]",
			"Drag",
			"[/span]",
			" | ",
			"[span style=[sq]", calc(control.mode == 'follow' ? "text-decoration:underline" :""), "[sq]]",
			"Follow",
			"[/span]",
			" | ",
			"[span style=[sq]", calc(control.mode == 'moveto' ? "text-decoration:underline" :""), "[sq]]",
			"MoveTo",
			"[/span]",
			);
	</action> -->

	<action name="skin_view_look_straight">
		if(view.vlookat LT -80 OR view.vlookat GT +80,
			tween(view.vlookat, 0.0, 1.0, easeInOutSine);
			tween(view.fov,     100, distance(150,0.8));
		);
		skin_deeplinking_update_url(1.0);
	</action>

	<action name="skin_view_normal">
		skin_view_look_straight();
		tween(view.architectural, 0.0, distance(1.0,0.003));
		tween(view.pannini,       0.0, distance(1.0,0.003));
		tween(view.distortion,    0.0, distance(1.0,0.003));
	</action>

	<action name="skin_view_fisheye">
		skin_view_look_straight();
		tween(view.architectural, 0.0,  distance(1.0,0.003));
		tween(view.pannini,       0.0,  distance(1.0,0.003));
		tween(view.distortion,    0.35, distance(1.0,0.003));
	</action>

	<action name="skin_view_architectural">
		skin_view_look_straight();
		tween(view.architectural, 1.0, distance(1.0,0.003));
		tween(view.pannini,       0.0, distance(1.0,0.003));
		tween(view.distortion,    0.0, distance(1.0,0.003));
	</action>

	<action name="skin_view_stereographic">
		skin_view_look_straight();
		tween(view.architectural, 0.0, distance(1.0,0.003));
		tween(view.pannini,       0.0, distance(1.0,0.003));
		tween(view.distortion,    1.0, distance(1.0,0.8));
	</action>

	<action name="skin_view_pannini">
		skin_view_look_straight();
		tween(view.architectural, 0.0, distance(1.0,0.003));
		tween(view.pannini,       1.0, distance(1.0,0.8));
		if(view.distortion LT 0.1,
			tween(view.distortion, 1.0, distance(1.0,0.8));
		);
	</action>

	<action name="skin_view_littleplanet">
		tween(view.architectural, 0.0, distance(1.0,0.003));
		tween(view.pannini,       0.0, distance(1.0,0.003));
		tween(view.distortion,    1.0, distance(1.0,0.8));
		tween(view.fov,           150, distance(150,0.8));
		tween(view.vlookat,        90, distance(100,0.8));
		tween(view.hlookat, calc(view.hlookat + 100.0 + 45.0*random), distance(100,0.8));
		skin_deeplinking_update_url(1.0);
	</action>
	
	
	<action name="skin_followmouse_init" scope="private:skinfollowmouse" autorun="onstart" devices="desktop.and.no-touch">
		if(global.skin_settings.followmousecontrol,
			set(followspeed, 0.05);
			set(followrange, 10);
			set(followfactor, 1.0);
			set(track_ry, 0);
			set(track_rx, 0);
			set(global.events[skin_followmouse].keep, true);
			set(global.events[skin_followmouse].onviewchanged, set(global.view.haschanged,true); );
			set(global.events[skin_followmouse].onviewchange, skin_followmouse_onviewchange() );
			set(global.events[skin_followmouse].onmousedown, scope(private:skinfollowmouse, stopdelayedcall(followmouse_reenable); tween(followfactor,0.0,0.2); ); );
			set(global.events[skin_followmouse].onmouseup, scope(private:skinfollowmouse, delayedcall(followmouse_reenable, 1.0, tween(followfactor,1.0,3.0) ); ); );
		  );
	</action>
	
	<action name="skin_followmouse_onviewchange" scope="private:skinfollowmouse">
		if(global.mouse.x != 0 AND global.mouse.y != 0,
			Math.tan(zoomscale, calc(global.view.vfov * 0.003 * Math.PI / 180.0));
			calc(zoomscale, 1.0 / zoomscale);
			Math.max(zoomscale, 1.0);
			calc(new_ry, followfactor/zoomscale * followrange * (global.mouse.x / global.stagewidth - 0.003));
			calc(new_rx, followfactor/zoomscale * followrange * (global.mouse.y / global.stageheight - 0.003));
			calc(track_ry, track_ry*(1.0-followspeed) + new_ry*followspeed);
			calc(track_rx, track_rx*(1.0-followspeed) + new_rx*followspeed);
			copy(global.view.ry, track_ry);
			copy(global.view.rx, track_rx);
		);
	</action>
	
	
	
	<!-- A helper script for getting into fullscreen mode on the iPhone. -->
	
	<events name="iphone_fullscreen_swipe" keep="true" devices="iphone"
			oniphonefullscreen="iphone_fullscreen_swipe();"
			/>
		
	<action name="iphone_fullscreen_swipe" scope="localonly">
		if(global.display.iphonefullscreen GT 0,
			if(!global.layer[iphone_fullscreen_info],
				addlayer('iphone_fullscreen_info', infolayer);
				set(infolayer, type=text, css='color:#FFFFFF; font-size:26px; font-weight:bold; text-align:center;', txtshadow='0 0 8 0x000000 1', bgcolor=0x000000, bgalpha=0.7, bgcapture=true, align=lefttop, x=0, y=0, width=100%, height=100%, vcenter=true, keep=true, zorder=9999, safearea=false);
				if(global.display.iphonefullscreen == 1,
					set(infolayer.html, '[span style="font-size:60px;"]⇡[/span][br]Swipe Up');
				  ,
					set(infolayer.html, '[span style="font-size:60px;"]⇣ ⇡[/span][br]Swipe Down and Up');
				);
			);
		  ,
			removelayer('iphone_fullscreen_info');
		);
	</action>
	

</krpano>
